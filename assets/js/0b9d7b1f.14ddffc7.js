(self.webpackChunkawesome_ha_blueprints_website=self.webpackChunkawesome_ha_blueprints_website||[]).push([[396],{616:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation/simple_safe_scheduler","title":"Simple Safe Scheduler","description":"A simple scheduler which executes a certain action at a given time, checking and eventually re-executing the action if the automation did not run at the expected time (e.g. due to a disruptive event).","source":"@site/docs/blueprints/automation/simple_safe_scheduler.mdx","sourceDirName":"blueprints/automation","slug":"/blueprints/automation/simple_safe_scheduler","permalink":"/awesome-ha-blueprints/docs/blueprints/automation/simple_safe_scheduler","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation/simple_safe_scheduler.mdx","tags":[],"version":"current","frontMatter":{"title":"Simple Safe Scheduler","description":"A simple scheduler which executes a certain action at a given time, checking and eventually re-executing the action if the automation did not run at the expected time (e.g. due to a disruptive event)."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Simple Safe Scheduler",description:"A simple scheduler which executes a certain action at a given time, checking and eventually re-executing the action if the automation did not run at the expected time (e.g. due to a disruptive event)."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Storage Input",id:"helper---storage-input",level:3},{value:"Advanced scheduling",id:"advanced-scheduling",level:3},{value:"Dynamic scheduling (e.g. sunrise/sunset)",id:"dynamic-scheduling-eg-sunrisesunset",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"simple_safe_scheduler",category:"automation"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"Scheduling a periodic action in Home Assistant might be trickier than what it looks at first glance. Not only the available automation triggers are limited to only time-based schedules (requiring the user to either use template triggers or install additional integrations for more complex scheduling options), but they also do not guarantee that the automation is executed at the provided time."}),"\n",(0,i.jsxs)(n.p,{children:["As an example, let's assume automation ",(0,i.jsx)(n.em,{children:"A"})," is scheduled to run at 12:00. If the Home Assistant server goes down at 11:59 due to a disruptive event (e.g. power outage, planned maintenance, hardware failure etc.) and comes back up at 12:01, the ",(0,i.jsx)(n.em,{children:"A"})," automation run scheduled for 12:00 would simply be skipped, without any warning to the user."]}),"\n",(0,i.jsx)(n.p,{children:"The Simple Safe Scheduler blueprint tries to mitigate scheduling limitations in Home Assistant by providing an easy interface to configure periodic actions, with built-in safety checks to ensure the action actually runs even in case of a disruptive event."}),"\n",(0,i.jsx)(n.p,{children:"The configured automation acts as a simple scheduler, allowing to flexibly program any kind of action based on the following parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Time of the day (dynamically provided as an ",(0,i.jsx)(n.code,{children:"input_datetime"})," entity);"]}),"\n",(0,i.jsx)(n.li,{children:"Day of the week (multiple days can be selected);"}),"\n",(0,i.jsx)(n.li,{children:"Week frequency (allowing to schedule the action to run i.e. every 2 weeks)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In addition, the blueprint implements useful checks to make sure that, in case of a disruptive event (e.g power outage, Home Assistant server outage etc.) happening at the scheduled automation run time, the action is executed as soon as the system restores its state. These checks can be configured to be performed both when Home Assistant boots up and when a custom event is fired (e.g. from another automation or integration). Such safety checks might be particularly important for critical automations, which need to run as close as possible to the scheduled time (e.g. watering plants, configuring an alarm system, etc.)."}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Datetime Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the entity which represents a datetime input in Home Assistant. It should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_datetime/",children:"Input Datetime Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"automation",id:"simple_safe_scheduler"}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---storage-input",children:"Helper - Storage Input"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_storage"})," (Helper - Storage) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. When setting up this blueprint, manually create a new ",(0,i.jsx)(n.code,{children:"input_text"})," entity and provide it in the inputs section."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["Make sure the text input is not altered by any other agent. The provided entity is used as a permanent storage area for just a single automation; any change to its state not carried out by the respective automation could lead to inconsistencies and unexpected behaviour. Therefore, you should create a ",(0,i.jsx)(n.strong,{children:"separate text input for each automation you're configuring with this blueprint"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-scheduling",children:"Advanced scheduling"}),"\n",(0,i.jsx)(n.p,{children:"For more advanced scheduling options you can configure multiple automation with this blueprint, having the same action but with a different scheduling configuration.\nLet's say that you want to set up an action to run every two weeks on Monday, at 12:00 and also every week on Wednesday, at 13:00. You can setup two distinct automations with the same action and the following scheduling configuration (only scheduling-relevant inputs are provided):"}),"\n",(0,i.jsx)(n.p,{children:"Automation 1: Every two weeks, on Monday, at 12:00:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"weeks_frequency: 2\nday_monday: true\ntime_entity: input_datetime.automation_1 # its value need to be set at 12:00\n"})}),"\n",(0,i.jsx)(n.p,{children:"Automation 2: Every week, on Wednesday, at 13:00:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"weeks_frequency: 1\nday_wednesday: true\ntime_entity: input_datetime.automation_2 # its value need to be set at 13:00\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-scheduling-eg-sunrisesunset",children:"Dynamic scheduling (e.g. sunrise/sunset)"}),"\n",(0,i.jsxs)(n.p,{children:["Using an ",(0,i.jsx)(n.code,{children:"input_datetime"})," entity to provide the time the automation should run allows to flexibly configure the scheduled time, without providing an hardcoded value. This can be really useful when configuring schedules based on a dynamic time of the day, such as sunrise or sunset based automations. In the latter case, you can provide an ",(0,i.jsx)(n.code,{children:"input_datetime"})," entity configured as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# input_datetime configuration\ninput_datetime:\n  automation_1:\n    name: Automation 1 Execution Time\n    has_date: false\n    has_time: true\n\n# your automations.yaml file\n- id: automation_1_datetime_update\n  # whenever you want to update the automation dynamic execution time\n  # in this case at sunset\n  trigger:\n    - platform: sun\n      event: sunset\n  action:\n    - service: input_datetime.set_datetime\n      target:\n        entity_id: input_datetime.automation_1\n      data:\n        time: \"{{ now().strftime('%H:%M:%S') }}\"\n"})}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-10-22"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},719:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 929002398602 Hue Dimmer switch v2\n  description: |\n    # Controller - Philips 929002398602 Hue Dimmer switch v2\n\n    Controller automation for executing any kind of action triggered by the provided Philips 929002398602 Hue Dimmer switch v2. Allows to optionally loop an action on a button long press.\n    Supports ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_929002398602/philips_929002398602.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/929002398602.html#philips-929002398602\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch (929002398602)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # **TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # **TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_on_short:\n      name: (Optional) On button short press\n      description: Action to run on short on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_long:\n      name: (Optional) On button long press\n      description: Action to run on long on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_release:\n      name: (Optional) On button release\n      description: Action to run on on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_on_double:\n      name: (Optional) (Virtual) On button double press\n      description: Action to run on double on button press.\n      default: []\n      selector:\n        action:\n    action_button_off_short:\n      name: (Optional) Off button short press\n      description: Action to run on short off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_long:\n      name: (Optional) Off button long press\n      description: Action to run on long off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_release:\n      name: (Optional) Off button release\n      description: Action to run on off button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_off_double:\n      name: (Optional) (Virtual) Off button double press\n      description: Action to run on double off button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_on_long_loop:\n      name: (Optional) On button long press - loop until release\n      description: Loop the on button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_on_long_max_loop_repeats:\n      name: (Optional) On button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_off_long_loop:\n      name: (Optional) Off button long press - loop until release\n      description: Loop the off button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_off_long_max_loop_repeats:\n      name: (Optional) Off button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_on_double_press:\n      name: (Optional) Expose on button double press event\n      description: Choose whether or not to expose the virtual double press event for the on button. Turn this on if you are providing an action for the on button double press event.\n      default: false\n      selector:\n        boolean:\n    button_off_double_press:\n      name: (Optional) Expose off button double press event\n      description: Choose whether or not to expose the virtual double press event for the off button. Turn this on if you are providing an action for the off button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_on_long_loop: !input button_on_long_loop\n  button_on_long_max_loop_repeats: !input button_on_long_max_loop_repeats\n  button_on_double_press: !input button_on_double_press\n  button_off_long_loop: !input button_off_long_loop\n  button_off_long_max_loop_repeats: !input button_off_long_max_loop_repeats\n  button_off_double_press: !input button_off_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    zha:\n      button_on_short: [on_press, on_press_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_long_release]\n      button_off_short: [off_press, off_press_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_long_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_long_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/929002398602.html#philips-929002398602\n      button_on_short: [on_press, on_press_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_hold_release]\n      button_off_short: [off_press, off_press_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_hold_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_hold_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_hold_release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_on_short: '{{ actions_mapping[integration_id][\"button_on_short\"] }}'\n  button_on_long: '{{ actions_mapping[integration_id][\"button_on_long\"] }}'\n  button_on_release: '{{ actions_mapping[integration_id][\"button_on_release\"] }}'\n  button_off_short: '{{ actions_mapping[integration_id][\"button_off_short\"] }}'\n  button_off_long: '{{ actions_mapping[integration_id][\"button_off_long\"] }}'\n  button_off_release: '{{ actions_mapping[integration_id][\"button_off_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold_release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_on_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_on_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_on_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_on_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_on_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_on_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_on_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_on_short\n      - conditions: '{{ trigger_action | string in button_on_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_on_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_on_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_on_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_on_long\n      - conditions: '{{ trigger_action | string in button_on_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_on_release\n      - conditions: '{{ trigger_action | string in button_off_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_off_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_off_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_off_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_off_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_off_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_off_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_off_short\n      - conditions: '{{ trigger_action | string in button_off_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_off_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_off_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_off_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_off_long\n      - conditions: '{{ trigger_action | string in button_off_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_off_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},849:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n  description: |\n    # Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.04.01\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743/#changelog)\n    \ud83d\udcd5 [Full documentation](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743)\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1743/ikea_e1743.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1743.html#ikea-e1743\n            # source: https://zigbee.blakadder.com/Ikea_E1743.html\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI on/off switch\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI on/off switch (E1743)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI on/off switch\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI on/off switch\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off_0_83]\n      button_up_release: [stop]\n      button_down_short: ['off']\n      button_down_long: [move_1_83]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1743.html#ikea-e1743\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_up\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_down\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},969:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers","title":"Controllers","description":"Integrate a wide set of controllers in Home Assistant and provide an easy to use interface to run custom actions on a controller event.","source":"@site/docs/blueprints/controllers.mdx","sourceDirName":"blueprints","slug":"/blueprints/controllers","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers.mdx","tags":[],"version":"current","frontMatter":{"title":"Controllers","description":"Integrate a wide set of controllers in Home Assistant and provide an easy to use interface to run custom actions on a controller event."},"sidebar":"docs","previous":{"title":"Overview","permalink":"/awesome-ha-blueprints/docs/blueprints"},"next":{"title":"Hooks","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks"}}');var i=t(7557),r=t(7389),s=t(2864);t(8225);const l={title:"Controllers",description:"Integrate a wide set of controllers in Home Assistant and provide an easy to use interface to run custom actions on a controller event."},a=void 0,d={},c=[{value:"Supported Controllers",id:"supported-controllers",level:3}];function u(e){const n={a:"a",admonition:"admonition",em:"em",h3:"h3",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Controllers are part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Controllers"})," are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them. They consist in a practical abstraction layer for easily building controlled-based automations without worrying about the handling of RAW controller events, and the integration used to connect controllers to Home Assistant (Zigbee2MQTT, ZHA, deCONZ, etc.)."]}),"\n",(0,i.jsxs)(n.p,{children:["You can integrate Controllers with ",(0,i.jsx)(n.a,{href:"hooks",children:"Hooks"})," and create controller-based automations to control lights, media players and much more, without having to write a single line of code."]}),"\n",(0,i.jsx)(n.h3,{id:"supported-controllers",children:"Supported Controllers"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Can't find the controller you're looking for in this list? ",(0,i.jsx)(n.a,{href:"https://github.com/EPMatt/awesome-ha-blueprints/issues/new?assignees=&labels=blueprint%2Cnew%2Ccontroller&template=new-controller-support.md&title=New+Controller+-+",children:"Submit a new blueprint proposal for your controller here."})]})}),"\n",(0,i.jsx)(s.mV,{})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1033:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/hooks/light","title":"Hook - Light","description":"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights.","source":"@site/docs/blueprints/hooks/light.mdx","sourceDirName":"blueprints/hooks","slug":"/blueprints/hooks/light","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks/light","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/hooks/light.mdx","tags":[],"version":"current","frontMatter":{"title":"Hook - Light","description":"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Hook - Light",description:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Supported Controllers",id:"supported-controllers",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"light",category:"hooks"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["An automation created with this blueprint must be linked to a ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers",children:"Controller"})," automation. Controllers are blueprints which allow to easily integrate a wide range of controllers and use them to run a set of actions when interacting with them. They expose an abstract interface used by Hooks to create controller-based automations."]}),(0,i.jsxs)(n.p,{children:["See the list of ",(0,i.jsx)(n.a,{href:"#supported-controllers",children:"Controllers supported by this Hook"})," for additional details."]})]}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"controller",required:!0}),"\n",(0,i.jsxs)(s.Kg,{name:"Light Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the entity which represents a light in Home Assistant. It should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/light/",children:"Light Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"hooks",id:"light"}),"\n",(0,i.jsx)(n.h2,{id:"supported-controllers",children:"Supported Controllers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Aqara WXKG11LM Wireless Mini Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1524_e1810",children:"IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1743",children:"IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1744",children:"IKEA E1744 SYMFONISK Rotary Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1766",children:"IKEA E1766 TR\xc5DFRI Open/Close Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1812",children:"IKEA E1812 TR\xc5DFRI Shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2001_e2002",children:"IKEA E2001/E2002 STYRBAR Remote control"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2123",children:"IKEA E2123 SYMFONISK sound remote, gen 2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2201",children:"IKEA E2201 RODRET Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2213",children:"IKEA E2213 SOMRIG shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_ictc_g_1",children:"IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/osram_ac025xx00nj",children:"OSRAM AC025XX00NJ SMART+ Switch Mini"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_324131092621",children:"Philips 324131092621 Hue Dimmer switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_8718699693985",children:"Philips 8718699693985 Hue Smart Button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_929002398602",children:"Philips 929002398602 Hue Dimmer switch v2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/sonoff_snzb01",children:"SONOFF SNZB-01 Wireless Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA",children:"Tuya ERS-10TZBVK-AA Smart knob"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg11lm",children:"Xiaomi WXCJKG11LM Aqara Opple 2 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg12lm",children:"Xiaomi WXCJKG12LM Aqara Opple 4 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg13lm",children:"Xiaomi WXCJKG13LM Aqara Opple 6 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Xiaomi WXKG01LM Mi Wireless Switch"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to link multiple lights to the same controller you can either use ",(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/light.group/",children:"Light Groups"})," or build multiple Hooks linked to the same Controller."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-04"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-07"}),": add support for IKEA E1744 SYMFONISK rotary remote"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-14"}),": add support for IKEA E1812 Shortcut button, fix E1743 naming"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),": update action mapping for IKEA E1744. If you're using this Hook with an IKEA E1744, please update also the corresponding Controller blueprint"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"set minimum and maximum light brightness"}),"\n",(0,i.jsx)(n.li,{children:"specify number of steps from min to max brightness, both for short and long actions, when controlling the light"}),"\n",(0,i.jsx)(n.li,{children:"allow to force brightness to a specific value when turning on the light"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-27"}),": add support for Philips Hue dimmer switch"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-06"}),": fix light color modes not allowing to configure an automation with color temperature control."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-15"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"add smooth power on/off features"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"breaking change"}),": by default the light now turns off when a brightness down command is received and light is at minimum brightness. To disable this behaviour, turn off the smooth power off feature."]}),"\n",(0,i.jsx)(n.li,{children:"fix some optional fields name."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": remove unused variable, fix warnings for undefined variables in Home Assistant Core >=2021.4.0"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-16"}),": Add support for Osram SMART+ Switch Mini"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-03"}),": Add support for Philips Hue Smart Button"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Standardize blueprints structure and inputs naming across the whole collection."}),"\n",(0,i.jsx)(n.li,{children:"Improve blueprint documentation."}),"\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add support for alternate mappings. Additional mappings for currently supported controllers will be added from now on. Refer to the documentation of your controller for more details."]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": update controller names in the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, to match the full name of controllers, prevent ambiguities and enable support for alternate mappings. After updating this blueprint, please reconfigure your automations by selecting again the value for the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, matching the full name of the controller you're using with this hook."]}),"\n",(0,i.jsx)(n.li,{children:"Fix for remembering brightness level when turning on, where brightness level unavailable when light off."}),"\n",(0,i.jsx)(n.li,{children:"Added secondary mapping for IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-29"}),": Add support for IKEA E1766 TR\xc5DFRI Open/Close Remote."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-07"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add support for IKEA E2001/E2002 STYRBAR Remote control."}),"\n",(0,i.jsx)(n.li,{children:"Fix color mode automatic detection not working properly with color temperature lights."}),"\n",(0,i.jsx)(n.li,{children:'Add "None" color mode to completely disable color control features.'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-21"}),": Add support for Philips 929002398602 Hue Dimmer switch v2."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": Add support for Xiaomi WXCJKG11LM, WXCJKG12LM, WXCJKG13LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-05"}),": Added secondary mapping for IKEA E2001/E2002"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-22"}),": Add support for Xiaomi WXKG11LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-30"}),": Add support for SONOFF SNZB-01."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-16"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Add support for Xiaomi WXKG01LM Mi Wireless Switch, rename Xiaomi WXKG11LM Aqara Wireless Switch Mini to Aqara WXKG11LM Wireless Mini Switch"}),"\n",(0,i.jsxs)(n.p,{children:["If you had configured the ",(0,i.jsx)(n.code,{children:"controller_model"})," input to ",(0,i.jsx)(n.code,{children:"Xiaomi WXKG11LM Aqara Wireless Switch Mini"}),", please change it to ",(0,i.jsx)(n.code,{children:"Aqara WXKG11LM Wireless Mini Switch"}),".\nThe change has been implemented to match the controller with the correct manufacturer name (Aqara)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-18"}),': use min_brightness and max_brightness as conditions instead of "while true" loops ',(0,i.jsx)(n.a,{href:"https://github.com/Nicolai-",children:"@Nicolai-"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Added support for IKEA E2201 RODRET Dimmer. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-26"}),": Added support for IKEA E2213 SOMRIG shortcut button. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-28"}),": Added support for IKEA E2123 SYMFONISK sound remote, gen 2. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-29"}),": Added support for Tuya ERS-10TZBVK-AA Smart knob. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1044:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_ictc_g_1","title":"Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_ictc_g_1.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_ictc_g_1","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_ictc_g_1.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"ICTC-G-1","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer",description:"Controller automation for executing any kind of action triggered by the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"ICTC-G-1",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_ictc_g_1",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to optionally loop the rotate actions while the remote is rotating either left or right. Once the remote stops rotating, the loop stops as well. This is useful when rotating the controller should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_ictc_g_1#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.Kg,{id:"zigbee2mqtt",children:[(0,i.jsx)(s.Kg,{id:"zha"}),(0,i.jsx)(s.Kg,{id:"deconz"}),(0,i.jsxs)(n.p,{children:["When configuring the remote with Zigbee2MQTT make sure to disable the legacy integration for it, as reported ",(0,i.jsx)(n.a,{href:"https://www.zigbee2mqtt.io/devices/ICTC-G-1.html#legacy-integration",children:"here"}),". This blueprint won't work with controllers with a legacy integration due to their instability and fundamental problems."]})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_ictc_g_1"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Brightness down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Brightness up (continuous, until stop)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Volume down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Volume up (continuous, until stop)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The helper is used to determine stop rotation events when the controller is integrated with Zigbee2MQTT, ZHA, because of the actions mapping for the controller with these integrations. Natively, the controller doesn't allow to distinguish between different rotation events, so the blueprint must store the previous rotation."}),"\n",(0,i.jsxs)(n.p,{children:["This blueprint provides beta support for controllers integrated with deCONZ, since not all the supported events are mapped for this integration. If you are using the IKEA ICTC-G-1 with deCONZ and would like to help, you can reach out ",(0,i.jsx)(n.a,{href:"https://community.home-assistant.io/t/awesome-ha-blueprints-a-curated-list-of-blueprints-easily-create-controller-based-automations-remotes-switches-for-controlling-lights-media-players-and-more/256687",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": Fix stop rotation events not being detected with deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with two new blueprint inputs"}),"\n",(0,i.jsx)(n.li,{children:"Use any RAW stop event (left/right) to identify the stop event corresponding to the current remote rotation"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n",(0,i.jsx)(n.li,{children:"Fix for Zigbee2MQTT reporting null state changes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-04"}),": Fix deCONZ rotation stop events not being properly recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1209:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - OSRAM AC025XX00NJ SMART+ Switch Mini\n  description: |\n    # Controller - OSRAM AC025XX00NJ SMART+ Switch Mini\n\n    Controller automation for executing any kind of action triggered by the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/osram_ac025xx00nj/osram_ac025xx00nj.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/AC0251100NJ_AC0251600NJ_AC0251700NJ.html#osram-ac0251100nj-ac0251600nj-ac0251700nj\n            - integration: mqtt\n              manufacturer: OSRAM\n              model: Smart+ switch mini\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: OSRAM\n              model: Smart+ switch mini (AC0251100NJ/AC0251600NJ/AC0251700NJ)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: OSRAM\n            # **TBConfirmed** model: Lightify Switch Mini\n            - integration: deconz\n            # **TBConfirmed** manufacturer: OSRAM\n            # **TBConfirmed** model: Lightify Switch Mini\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_center_short:\n      name: (Optional) Center button short press\n      description: Action to run on short center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_long:\n      name: (Optional) Center button long press\n      description: Action to run on long center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_release:\n      name: (Optional) Center button release\n      description: Action to run on center button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_center_double:\n      name: (Optional) (Virtual) Center button double press\n      description: Action to run on double center button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_center_long_loop:\n      name: (Optional) Center button long press - loop until release\n      description: Loop the center button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_center_long_max_loop_repeats:\n      name: (Optional) Center button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_center_double_press:\n      name: (Optional) Expose center button double press event\n      description: Choose whether or not to expose the virtual double press event for the center button. Turn this on if you are providing an action for the center button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_center_long_loop: !input button_center_long_loop\n  button_center_long_max_loop_repeats: !input button_center_long_max_loop_repeats\n  button_center_double_press: !input button_center_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_center_short: ['3002']\n      button_center_long: ['3001']\n      button_center_release: ['3003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off]\n      button_up_release: [stop]\n      button_center_short: [move_to_level_with_on_off]\n      button_center_long: [move_to_saturation]\n      button_center_release: [move_hue]\n      button_down_short: ['off']\n      button_down_long: [move]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/AC0251100NJ_AC0251600NJ_AC0251700NJ.html#actions\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_center_short: [brightness_move_to_level]\n      button_center_long: [move_to_saturation]\n      button_center_release: [hue_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_center_short: '{{ actions_mapping[integration_id][\"button_center_short\"] }}'\n  button_center_long: '{{ actions_mapping[integration_id][\"button_center_long\"] }}'\n  button_center_release: '{{ actions_mapping[integration_id][\"button_center_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_to_level\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: move_to_saturation\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hue_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_center_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_center_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_center_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_center_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_center_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_center_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_center_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_center_short\n      - conditions: '{{ trigger_action | string in button_center_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_center_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_center_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_center_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_center_long\n      - conditions: '{{ trigger_action | string in button_center_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},1212:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Light\n  description: |\n    # Hook - Light\n\n    Hook automation which allows to control a light. Supports brightness and color control both for white temperature and rgb lights. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.29\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/light).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/light/light.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Light. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer (#2)\n            - IKEA E1744 SYMFONISK Rotary Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote (#2)\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2001/E2002 STYRBAR Remote control\n            - IKEA E2001/E2002 STYRBAR Remote control (#2)\n            - IKEA E2123 SYMFONISK sound remote, gen 2\n            - IKEA E2201 RODRET Dimmer\n            - IKEA E2201 RODRET Dimmer (#2)\n            - IKEA E2213 SOMRIG shortcut button\n            - IKEA E2213 SOMRIG shortcut button (#2)\n            - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n            - OSRAM AC025XX00NJ SMART+ Switch Mini\n            - Philips 324131092621 Hue Dimmer switch\n            - Philips 8718699693985 Hue Smart Button\n            - Philips 929002398602 Hue Dimmer switch v2\n            - SONOFF SNZB-01 Wireless Switch\n            - Tuya ERS-10TZBVK-AA Smart knob\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    light:\n      name: (Required) Light\n      description: Light which will be controlled with this automation.\n      selector:\n        entity:\n          domain: light\n    light_color_mode:\n      name: (Optional) Light color mode\n      description: Specify how the controller will set the light color. Choose \"Color Temperature\" and \"Hue - Saturation\" depending on the features supported by your light. If you are not sure you can select \"Auto\". \"None\" will disable color control features.\n      default: Auto\n      selector:\n        select:\n          options:\n            - Auto\n            - Color Temperature\n            - Hue - Saturation\n            - None\n    light_transition:\n      name: (Optional) Light Transition\n      description: Number that represents the time (in milliseconds) the light should take turn on or off, if the light supports it.\n      default: 250\n      selector:\n        number:\n          min: 0\n          max: 60000\n          step: 1\n          unit_of_measurement: milliseconds\n          mode: box\n    min_brightness:\n      name: (Optional) Light minimum brightness\n      description: The minimum brightness the light can be set with this automation.\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    max_brightness:\n      name: (Optional) Light maximum brightness\n      description: The maximum brightness the light can be set with this automation.\n      default: 255\n      selector:\n        number:\n          min: 0\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    brightness_steps_short:\n      name: (Optional) Light brightness steps - short actions\n      description: Number of steps from min to max brightness when controlling brightness with short actions (eg. button press).\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    brightness_steps_long:\n      name: (Optional) Light brightness steps - long actions\n      description: Number of steps from min to max brightness when controlling brightness with long actions (eg. button hold or controller rotation).\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 255\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    force_brightness:\n      name: (Optional) Force brightness value at turn on\n      description: Force brightness to the \"On brightness\" input value, when the light is being turned on.\n      default: false\n      selector:\n        boolean:\n    on_brightness:\n      name: (Optional) On brightness\n      description: Brightness value to force when turning on the light\n      default: 1\n      selector:\n        number:\n          min: 0\n          max: 255\n          step: 1\n          unit_of_measurement: brightness\n          mode: slider\n    smooth_power_on:\n      name: (Optional) Smooth power on\n      description: Force the light to turn on at minimum brightness when a brightness up command (single or continuous) is triggered and light is off.\n      default: true\n      selector:\n        boolean:\n    smooth_power_off:\n      name: (Optional) Smooth power off\n      description: Allow a brightness down command (single or continuous) to turn off the light when at minimum brightness. Disabling this will prevent the light from being turned off by brightness down commands.\n      default: true\n      selector:\n        boolean:\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      toggle: button_short\n      color_up: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n      toggle: button_center_short\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n    IKEA E1744 SYMFONISK Rotary Remote:\n      brightness_down_repeat: rotate_left\n      brightness_up_repeat: rotate_right\n      toggle: click_short\n      color_up: click_double\n      color_down: click_triple\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      brightness_up: button_up_short\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      turn_off: button_down_double\n    IKEA E1766 TR\xc5DFRI Open/Close Remote (#2):\n      brightness_up: button_up_short\n      color_up: button_up_double\n      brightness_down: button_down_short\n      color_down: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      toggle: button_short\n      color_up: button_double\n    IKEA E2001/E2002 STYRBAR Remote control:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n    IKEA E2001/E2002 STYRBAR Remote control (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n      color_down: button_left_short\n      color_down_repeat: button_left_long\n      color_up: button_right_short\n      color_up_repeat: button_right_long\n    IKEA E2123 SYMFONISK sound remote, gen 2:\n      toggle: button_center_short\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      color_up: button_right_short\n      color_down: button_left_short\n      turn_off: button_dots1_short\n      turn_on: button_dots2_short\n      color_down_repeat: button_dots1_long\n      color_up_repeat: button_dots2_long\n    IKEA E2201 RODRET Dimmer:\n      turn_on: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      turn_off: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n    IKEA E2201 RODRET Dimmer (#2):\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      turn_on: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      turn_off: button_down_double\n    IKEA E2213 SOMRIG shortcut button:\n      turn_on: button_dots1_short\n      brightness_up_repeat: button_dots1_long\n      color_up: button_dots1_double\n      turn_off: button_dots2_short\n      brightness_down_repeat: button_dots2_long\n      color_down: button_dots2_double\n    IKEA E2213 SOMRIG shortcut button (#2):\n      brightness_up: button_dots1_short\n      brightness_up_repeat: button_dots1_long\n      turn_on: button_dots1_double\n      brightness_down: button_dots2_short\n      brightness_down_repeat: button_dots2_long\n      turn_off: button_dots2_double\n    IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer:\n      brightness_down_repeat: rotate_left\n      brightness_up_repeat: rotate_right\n    OSRAM AC025XX00NJ SMART+ Switch Mini:\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      color_up: button_up_double\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n      color_down: button_down_double\n      toggle: button_center_short\n    Philips 324131092621 Hue Dimmer switch:\n      turn_on: button_on_short\n      color_up_repeat: button_on_long\n      turn_off: button_off_short\n      color_down_repeat: button_off_long\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n    Philips 8718699693985 Hue Smart Button:\n      toggle: button_short\n    Philips 929002398602 Hue Dimmer switch v2:\n      turn_on: button_on_short\n      color_up_repeat: button_on_long\n      turn_off: button_off_short\n      color_down_repeat: button_off_long\n      brightness_up: button_up_short\n      brightness_up_repeat: button_up_long\n      brightness_down: button_down_short\n      brightness_down_repeat: button_down_long\n    SONOFF SNZB-01 Wireless Switch:\n      toggle: button_short\n      color_up: button_double\n    Tuya ERS-10TZBVK-AA Smart knob:\n      brightness_down: rotate_left\n      brightness_up: rotate_right\n      toggle: click_short\n      color_down: rotate_left_withpress\n      color_up: rotate_right_withpress\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      turn_on: button_3_short\n      brightness_up_repeat: button_3_long\n      color_up: button_3_double\n      turn_off: button_4_short\n      brightness_down_repeat: button_4_long\n      color_down: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      turn_on: button_1_short\n      brightness_up_repeat: button_1_long\n      color_up: button_1_double\n      turn_off: button_2_short\n      brightness_down_repeat: button_2_long\n      color_down: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      turn_on: button_3_short\n      brightness_up_repeat: button_3_long\n      color_up: button_3_double\n      turn_off: button_4_short\n      brightness_down_repeat: button_4_long\n      color_down: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      turn_on: button_5_short\n      brightness_up_repeat: button_5_long\n      color_up: button_5_double\n      turn_off: button_6_short\n      brightness_down_repeat: button_6_long\n      color_down: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      toggle: button_short\n      color_up: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  brightness_up: '{{ controller_mapping[controller_model][\"brightness_up\"] | default(None) }}'\n  brightness_up_repeat: '{{ controller_mapping[controller_model][\"brightness_up_repeat\"] | default(None) }}'\n  brightness_down: '{{ controller_mapping[controller_model][\"brightness_down\"] | default(None) }}'\n  brightness_down_repeat: '{{ controller_mapping[controller_model][\"brightness_down_repeat\"] | default(None) }}'\n  color_up: '{{ controller_mapping[controller_model][\"color_up\"] | default(None) }}'\n  color_up_repeat: '{{ controller_mapping[controller_model][\"color_up_repeat\"] | default(None) }}'\n  color_down: '{{ controller_mapping[controller_model][\"color_down\"] | default(None) }}'\n  color_down_repeat: '{{ controller_mapping[controller_model][\"color_down_repeat\"] | default(None) }}'\n  toggle: '{{ controller_mapping[controller_model][\"toggle\"] | default(None) }}'\n  turn_on: '{{ controller_mapping[controller_model][\"turn_on\"] | default(None) }}'\n  turn_off: '{{ controller_mapping[controller_model][\"turn_off\"] | default(None) }}'\n  light_color_mode: !input light_color_mode\n  light: !input light\n  light_transition: !input light_transition\n  min_brightness: !input min_brightness\n  max_brightness: !input max_brightness\n  brightness_steps_short: !input brightness_steps_short\n  brightness_steps_long: !input brightness_steps_long\n  force_brightness: !input force_brightness\n  on_brightness: !input on_brightness\n  smooth_power_on: !input smooth_power_on\n  smooth_power_off: !input smooth_power_off\n  color_modes:\n    Auto: auto\n    Color Temperature: color_temp\n    Hue - Saturation: hs_color\n    None: none\n  # extract light color mode id\n  light_color_mode_id: >-\n    {%- if light_color_mode == \"Auto\" -%} {% set supported_color_modes = state_attr(light, \"supported_color_modes\") -%} {%- if \"hs\" in supported_color_modes or \"xy\" in supported_color_modes or \"rgbw\" in supported_color_modes or \"rgbww\" in supported_color_modes -%} {{\n    color_modes[\"Hue - Saturation\"] }} {%- elif \"color_temp\" in supported_color_modes -%} {{ color_modes[\"Color Temperature\"] }} {%- else -%} {{ color_modes[\"None\"] }} {%- endif -%} {%- else -%} {{ color_modes[light_color_mode] }} {%- endif -%}\n  step_short: '{{ (max_brightness-min_brightness)/brightness_steps_short }}'\n  step_long: '{{ (max_brightness-min_brightness)/brightness_steps_long }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\ncondition: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == toggle }}'\n        sequence:\n          - choose:\n              - conditions: '{{ force_brightness }}'\n                sequence:\n                  - action: light.toggle\n                    entity_id: !input light\n                    data:\n                      brightness: !input on_brightness\n                      transition: '{{ light_transition / 1000 }}'\n            default:\n              - action: light.toggle\n                entity_id: !input light\n                data:\n                  transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == turn_on }}'\n        sequence:\n          - choose:\n              - conditions: '{{ force_brightness }}'\n                sequence:\n                  - action: light.turn_on\n                    entity_id: !input light\n                    data:\n                      brightness: !input on_brightness\n                      transition: '{{ light_transition / 1000 }}'\n            default:\n              - action: light.turn_on\n                entity_id: !input light\n                data:\n                  transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == turn_off }}'\n        sequence:\n          - action: light.turn_off\n            entity_id: !input light\n            data:\n              transition: '{{ light_transition / 1000 }}'\n      - conditions: '{{ action == brightness_up }}'\n        sequence:\n          - choose:\n              # if light is off and smooth power on is disabled, turn it on at the previously saved brightness\n              - conditions: '{{ states(light) == \"off\" and not smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n              # if light is off and smooth power on is enabled, turn it on at minimum brightness\n              - conditions: '{{ states(light) == \"off\" and smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      brightness: '{{ min_brightness }}'\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n            # else the light is on, hence increase its brightness\n            default:\n              - action: light.turn_on\n                data:\n                  brightness: '{{ [ [state_attr(light,\"brightness\")+step_short, min_brightness] | max, max_brightness] | min }}'\n                  transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == brightness_down and states(light) == \"on\" }}'\n        sequence:\n          - choose:\n              - conditions: '{{ smooth_power_off and state_attr(light,\"brightness\") == min_brightness }}'\n                sequence:\n                  - action: light.turn_off\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n            default:\n              - action: light.turn_on\n                data:\n                  brightness: '{{ [ [state_attr(light,\"brightness\")-step_short, min_brightness] | max, max_brightness] | min }}'\n                  transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == brightness_up_repeat }}'\n        sequence:\n          # first step for the smooth power on feature: subsequent steps can skip this check since light will be already on\n          - choose:\n              # if light is off and smooth power on is disabled, turn it on at the previously saved brightness\n              - conditions: '{{ states(light) == \"off\" and not smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n                  - delay:\n                      milliseconds: !input light_transition\n              # if light is off and smooth power on is enabled, turn it on at minimum brightness\n              - conditions: '{{ states(light) == \"off\" and smooth_power_on}}'\n                sequence:\n                  - action: light.turn_on\n                    data:\n                      brightness: '{{ min_brightness }}'\n                      transition: '{{ light_transition / 1000 }}'\n                      entity_id: !input light\n                  - delay:\n                      milliseconds: !input light_transition\n          # else move on to the loop for increasing the light brightness until the maximum brightness is reached\n          - repeat:\n              while: '{{ state_attr(light,\"brightness\") < max_brightness }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    brightness: '{{ [ [state_attr(light,\"brightness\")+step_long, min_brightness] | max, max_brightness] | min }}'\n                    transition: 0.25\n                    entity_id: !input light\n                - delay:\n                    milliseconds: 250\n      - conditions: '{{ action == brightness_down_repeat and states(light) == \"on\"  }}'\n        sequence:\n          - choose:\n              # using a separate sequence for the smooth power off feature to not perform unnecessary checks at every iteration when the feature is disabled\n              - conditions: '{{ smooth_power_off }}'\n                sequence:\n                  - repeat:\n                      # continue lowering brightness until the light turns off\n                      while: '{{ states(light) != \"off\" }}'\n                      sequence:\n                        - choose:\n                            # if the light is at minimum brightness, turn it off\n                            - conditions: '{{ state_attr(light,\"brightness\") == min_brightness }}'\n                              sequence:\n                                - action: light.turn_off\n                                  data:\n                                    transition: '{{ light_transition / 1000 }}'\n                                    entity_id: !input light\n                                - delay:\n                                    milliseconds: !input light_transition\n                          # else lower the light's brightness\n                          default:\n                            - action: light.turn_on\n                              data:\n                                brightness: '{{ [ [state_attr(light,\"brightness\")-step_long, min_brightness] | max, max_brightness] | min }}'\n                                transition: 0.25\n                                entity_id: !input light\n                            - delay:\n                                milliseconds: 250\n            default:\n              - repeat:\n                  # continue lowering brightness until the light hits the minimum brightness\n                  while: '{{ state_attr(light,\"brightness\") > min_brightness }}'\n                  sequence:\n                    # lower the light's brightness. since smooth power off is disabled, never let the brightness move below the user-provided minimum\n                    - action: light.turn_on\n                      data:\n                        brightness: '{{ [ [state_attr(light,\"brightness\")-step_long, min_brightness] | max, max_brightness] | min }}'\n                        transition: 0.25\n                        entity_id: !input light\n                    - delay:\n                        milliseconds: 250\n      - conditions: '{{ action == color_up and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    color_temp: '{{ state_attr(light,\"color_temp\")|int(0) + 50 }}'\n                    transition: 0.25\n                  entity_id: !input light\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) + 15) % 360, 100] }}'\n                    transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == color_down and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    color_temp: '{{ [state_attr(light,\"color_temp\")|int(0) - 50, 1]|max }}'\n                    transition: 0.25\n                  entity_id: !input light\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - action: light.turn_on\n                  data:\n                    hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) - 15) % 360, 100] }}'\n                    transition: 0.25\n                  entity_id: !input light\n      - conditions: '{{ action == color_up_repeat and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          color_temp: '{{ state_attr(light,\"color_temp\")|int(0) + 50 }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) + 15) % 360, 100] }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n      - conditions: '{{ action == color_down_repeat and light_color_mode_id != \"none\" }}'\n        sequence:\n          choose:\n            - conditions: '{{ light_color_mode_id == \"color_temp\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          color_temp: '{{ [state_attr(light,\"color_temp\")|int(0) - 50, 1]|max }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n            - conditions: '{{ light_color_mode_id == \"hs_color\" }}'\n              sequence:\n                - repeat:\n                    while: '{{ true }}'\n                    sequence:\n                      - action: light.turn_on\n                        data:\n                          hs_color: '{{ [((state_attr(light,\"hs_color\")[0] or 0) - 15) % 360, 100] }}'\n                          transition: 0.25\n                        entity_id: !input light\n                      - delay:\n                          milliseconds: 250\n"},1320:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/hooks/cover","title":"Hook - Cover","description":"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover.","source":"@site/docs/blueprints/hooks/cover.mdx","sourceDirName":"blueprints/hooks","slug":"/blueprints/hooks/cover","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks/cover","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/hooks/cover.mdx","tags":[],"version":"current","frontMatter":{"title":"Hook - Cover","description":"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Hook - Cover",description:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Supported Controllers",id:"supported-controllers",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"cover",category:"hooks"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["An automation created with this blueprint must be linked to a ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers",children:"Controller"})," automation. Controllers are blueprints which allow to easily integrate a wide range of controllers and use them to run a set of actions when interacting with them. They expose an abstract interface used by Hooks to create controller-based automations."]}),(0,i.jsxs)(n.p,{children:["See the list of ",(0,i.jsx)(n.a,{href:"#supported-controllers",children:"Controllers supported by this Hook"})," for additional details."]})]}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"controller",required:!0}),"\n",(0,i.jsxs)(s.Kg,{name:"Cover Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the entity which represents a cover in Home Assistant. It should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/cover/",children:"Cover Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"hooks",id:"cover"}),"\n",(0,i.jsx)(n.h2,{id:"supported-controllers",children:"Supported Controllers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Aqara WXKG11LM Wireless Mini Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1524_e1810",children:"IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1743",children:"IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1766",children:"IKEA E1766 TR\xc5DFRI Open/Close Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1812",children:"IKEA E1812 TR\xc5DFRI Shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2123",children:"IKEA E2123 SYMFONISK sound remote, gen 2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2201",children:"IKEA E2201 RODRET Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2213",children:"IKEA E2213 SOMRIG shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/sonoff_snzb01",children:"SONOFF SNZB-01 Wireless Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg11lm",children:"Xiaomi WXCJKG11LM Aqara Opple 2 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg12lm",children:"Xiaomi WXCJKG12LM Aqara Opple 4 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg13lm",children:"Xiaomi WXCJKG13LM Aqara Opple 6 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Xiaomi WXKG01LM Mi Wireless Switch"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to link multiple covers to the same controller you can either use ",(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/cover.group/",children:"Cover Groups"})," or build multiple Hooks linked to the same Controller."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": remove unused variable, fix warnings for undefined variables in Home Assistant Core >=2021.4.0"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Standardize blueprints structure and inputs naming across the whole collection."}),"\n",(0,i.jsx)(n.li,{children:"Improve blueprint documentation."}),"\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add support for alternate mappings. Additional mappings for currently supported controllers will be added from now on. Refer to the documentation of your controller for more details."]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": update controller names in the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, to match the full name of controllers, prevent ambiguities and enable support for alternate mappings. After updating this blueprint, please reconfigure your automations by selecting again the value for the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, matching the full name of the controller you're using with this hook."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-29"}),": Add support for IKEA E1766 TR\xc5DFRI Open/Close Remote."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": Add support for Xiaomi WXCJKG11LM, WXCJKG12LM, WXCJKG13LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-22"}),": Add support for Xiaomi WXKG11LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-30"}),": Add support for SONOFF SNZB-01."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-16"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Add support for Xiaomi WXKG01LM Mi Wireless Switch, rename Xiaomi WXKG11LM Aqara Wireless Switch Mini to Aqara WXKG11LM Wireless Mini Switch"}),"\n",(0,i.jsxs)(n.p,{children:["If you had configured the ",(0,i.jsx)(n.code,{children:"controller_model"})," input to ",(0,i.jsx)(n.code,{children:"Xiaomi WXKG11LM Aqara Wireless Switch Mini"}),", please change it to ",(0,i.jsx)(n.code,{children:"Aqara WXKG11LM Wireless Mini Switch"}),".\nThe change has been implemented to match the controller with the correct manufacturer name (Aqara)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Added support for IKEA E2201 RODRET Dimmer. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-26"}),": Added support for IKEA E2213 SOMRIG shortcut button. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-28"}),": Added support for IKEA E2123 SYMFONISK sound remote, gen 2. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1552:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Cover\n  description: |\n    # Hook - Cover\n\n    Hook automation which allows to control a cover. Supports opening, closing and tilting the cover. Features may vary depending on the selected cover. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.28\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/cover).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/cover/cover.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Cover. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2123 SYMFONISK sound remote, gen 2\n            - IKEA E2201 RODRET Dimmer\n            - IKEA E2213 SOMRIG shortcut button\n            - SONOFF SNZB-01 Wireless Switch\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    cover:\n      name: (Required) Cover\n      description: Cover which will be controlled with this automation.\n      selector:\n        entity:\n          domain: cover\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      open_cover: button_up_short\n      close_cover: button_down_short\n      close_cover_tilt: button_left_short\n      open_cover_tilt: button_right_short\n      stop_cover_all: button_center_short\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      open_cover: button_up_short\n      open_cover_tilt: button_up_long\n      close_cover: button_down_short\n      close_cover_tilt: button_down_long\n      stop_cover_all: button_down_double\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      open_cover: button_up_short\n      close_cover: button_down_short\n      stop_cover_all: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    IKEA E2123 SYMFONISK sound remote, gen 2:\n      open_cover: button_up_short\n      close_cover: button_down_short\n      open_cover_tilt: button_right_short\n      close_cover_tilt: button_left_short\n      stop_cover_all: button_center_short\n    IKEA E2201 RODRET Dimmer:\n      open_cover: button_up_short\n      open_cover_tilt: button_up_long\n      close_cover: button_down_short\n      close_cover_tilt: button_down_long\n      stop_cover_all: button_down_double\n    IKEA E2213 SOMRIG shortcut button:\n      open_cover: button_dots1_short\n      open_cover_tilt: button_dots1_long\n      close_cover: button_dots2_short\n      close_cover_tilt: button_dots2_long\n      stop_cover_all: button_dots2_double\n    SONOFF SNZB-01 Wireless Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      open_cover: button_3_short\n      open_cover_tilt: button_3_long\n      close_cover: button_4_short\n      close_cover_tilt: button_4_long\n      stop_cover_all: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      open_cover: button_1_short\n      open_cover_tilt: button_1_long\n      close_cover: button_2_short\n      close_cover_tilt: button_2_long\n      stop_cover_all: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      open_cover: button_3_short\n      open_cover_tilt: button_3_long\n      close_cover: button_4_short\n      close_cover_tilt: button_4_long\n      stop_cover_all: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      open_cover: button_5_short\n      open_cover_tilt: button_5_long\n      close_cover: button_6_short\n      close_cover_tilt: button_6_long\n      stop_cover_all: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      open_cover: button_short\n      stop_cover_all: button_long\n      close_cover: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  open_cover: '{{ controller_mapping[controller_model][\"open_cover\"] | default(None) }}'\n  close_cover: '{{ controller_mapping[controller_model][\"close_cover\"] | default(None) }}'\n  open_cover_tilt: '{{ controller_mapping[controller_model][\"open_cover_tilt\"] | default(None) }}'\n  close_cover_tilt: '{{ controller_mapping[controller_model][\"close_cover_tilt\"] | default(None) }}'\n  stop_cover_all: '{{ controller_mapping[controller_model][\"stop_cover_all\"] | default(None) }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\nconditions: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == open_cover }}'\n        sequence:\n          - action: cover.open_cover\n            entity_id: !input cover\n      - conditions: '{{ action == close_cover }}'\n        sequence:\n          - action: cover.close_cover\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover }}'\n        sequence:\n          - action: cover.stop_cover\n            entity_id: !input cover\n      - conditions: '{{ action == open_cover_tilt }}'\n        sequence:\n          - action: cover.open_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == close_cover_tilt }}'\n        sequence:\n          - action: cover.close_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover_tilt }}'\n        sequence:\n          - action: cover.stop_cover_tilt\n            entity_id: !input cover\n      - conditions: '{{ action == stop_cover_all }}'\n        sequence:\n          - action: cover.stop_cover\n            entity_id: !input cover\n          - action: cover.stop_cover_tilt\n            entity_id: !input cover\n"},1902:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e2201","title":"Controller - IKEA E2201 RODRET Dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2201 RODRET Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e2201.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e2201","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e2201.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E2201 RODRET Dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2201 RODRET Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E2201","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E2201 RODRET Dimmer"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E2201 RODRET Dimmer",description:"Controller automation for executing any kind of action triggered by the provided IKEA E2201 RODRET Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E2201",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E2201 RODRET Dimmer"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e2201",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E2201 RODRET Dimmer. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. The blueprint will automagically detect the integration type and take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2201#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e2201"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color up"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color down"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn on"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn off"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Play/Pause"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Close the cover tilt"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Stop cover and cover tilt"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Initial release. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),") ","\ud83c\udf89"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20b"}),": Fix automation triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20c"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},2085:e=>{"use strict";e.exports='# Blueprint metadata\nblueprint:\n  name: Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n  description: |\n    # Controller - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer. Allows to optionally loop a custom action during controller rotation.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_ictc_g_1).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_ictc_g_1/ikea_ictc_g_1.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: \'\'\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/ICTC-G-1.html#ikea-ictc-g-1\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI wireless dimmer\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI wireless dimmer (ICTC-G-1)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI wireless dimmer\n            - integration: deconz\n              model: TRADFRI wireless dimmer\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: \'\'\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_rotate_left:\n      name: (Optional) Rotate left\n      description: Action to run on rotate left.\n      default: []\n      selector:\n        action:\n    action_rotate_left_stop:\n      name: (Optional) Rotate left stop\n      description: Action to run when stopping to rotate left the remote.\n      default: []\n      selector:\n        action:\n    action_rotate_right:\n      name: (Optional) Rotate right\n      description: Action to run on rotate right.\n      default: []\n      selector:\n        action:\n    action_rotate_right_stop:\n      name: (Optional) Rotate right stop\n      description: Action to run when stopping to rotate right the remote.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    rotate_left_loop:\n      name: (Optional) Rotate left - loop until stop\n      description: Loop the rotate left action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_left_max_loop_repeats:\n      name: (Optional) Rotate left - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    rotate_right_loop:\n      name: (Optional) Rotate right - loop until stop\n      description: Loop the rotate right action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_right_max_loop_repeats:\n      name: (Optional) Rotate right - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  rotate_left_loop: !input rotate_left_loop\n  rotate_left_max_loop_repeats: !input rotate_left_max_loop_repeats\n  rotate_right_loop: !input rotate_right_loop\n  rotate_right_max_loop_repeats: !input rotate_right_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: \'{{ integration | lower }}\'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      rotate_left: [\'3002\']\n      rotate_stop: []\n      rotate_right: [\'2002\']\n    zha:\n      rotate_left: [move_1_70, move_1_195]\n      rotate_stop: [stop]\n      rotate_right: [move_with_on_off_0_70, move_with_on_off_0_195]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/ICTC-G-1.html#ikea-ictc-g-1\n      rotate_left: [brightness_move_down]\n      rotate_stop: [brightness_stop]\n      rotate_right: [brightness_move_up]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  rotate_left: \'{{ actions_mapping[integration_id]["rotate_left"] }}\'\n  rotate_stop: \'{{ actions_mapping[integration_id]["rotate_stop"] }}\'\n  rotate_right: \'{{ actions_mapping[integration_id]["rotate_right"] }}\'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in ["","None"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it\'s the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n      trigger_delta: \'{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else as_timestamp("1970-01-01 00:00:00"))) * 1000 }}\'\n      last_controller_event: \'{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else "" }}\'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: \'{{ {"a":trigger_action,"t":as_timestamp(now())} | to_json }}\'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: \'{{ trigger_action | string in rotate_left }}\'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_left\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: \'{{ rotate_left_loop }}\'\n                sequence:\n                  - repeat:\n                      while: \'{{ repeat.index < rotate_left_max_loop_repeats | int }}\'\n                      sequence: !input action_rotate_left\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_left\n      - conditions:\n          - \'{{ trigger_action | string in rotate_stop }}\'\n          # check the previous event to determine the event which the received stop action is relative to\n          - \'{{ last_controller_event | string in rotate_left }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_left_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left_stop\n      - conditions: \'{{ trigger_action | string in rotate_right }}\'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_right\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: \'{{ rotate_right_loop }}\'\n                sequence:\n                  - repeat:\n                      while: \'{{ repeat.index < rotate_right_max_loop_repeats | int }}\'\n                      sequence: !input action_rotate_right\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_right\n      - conditions:\n          - \'{{ trigger_action | string in rotate_stop }}\'\n          # check the previous event to determine the event which the received stop action is relative to\n          - \'{{ last_controller_event | string in rotate_right }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: rotate_right_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right_stop\n'},2115:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n  description: |\n    # Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.04.01\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1524_e1810/ikea_e1524_e1810.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1524_E1810.html#ikea-e1524-e1810\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI remote control\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI remote control (E1524/E1810)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI remote control\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI remote control\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_left_short:\n      name: (Optional) Left button short press\n      description: Action to run on short left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_long:\n      name: (Optional) Left button long press\n      description: Action to run on long left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_release:\n      name: (Optional) Left button release\n      description: Action to run on left button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_left_double:\n      name: (Optional) (Virtual) Left button double press\n      description: Action to run on double left button press.\n      default: []\n      selector:\n        action:\n    action_button_right_short:\n      name: (Optional) Right button short press\n      description: Action to run on short right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_long:\n      name: (Optional) Right button long press\n      description: Action to run on long right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_release:\n      name: (Optional) Right button release\n      description: Action to run on right button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_right_double:\n      name: (Optional) (Virtual) Right button double press\n      description: Action to run on double right button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    action_button_center_short:\n      name: (Optional) Center button short press\n      description: Action to run on short center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_long:\n      name: (Optional) Center button long press\n      description: Action to run on long center button press.\n      default: []\n      selector:\n        action:\n    action_button_center_double:\n      name: (Optional) Center button double press\n      description: Action to run on double center button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_left_long_loop:\n      name: (Optional) Left button long press - loop until release\n      description: Loop the left button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_left_long_max_loop_repeats:\n      name: (Optional) Left button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_right_long_loop:\n      name: (Optional) Right button long press - loop until release\n      description: Loop the right button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_right_long_max_loop_repeats:\n      name: (Optional) Right button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_left_double_press:\n      name: (Optional) Expose left button double press event\n      description: Choose whether or not to expose the virtual double press event for the left button. Turn this on if you are providing an action for the left button double press event.\n      default: false\n      selector:\n        boolean:\n    button_right_double_press:\n      name: (Optional) Expose right button double press event\n      description: Choose whether or not to expose the virtual double press event for the right button. Turn this on if you are providing an action for the right button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    button_center_double_press:\n      name: (Optional) Expose center button double press event\n      description: Choose whether or not to expose the virtual double press event for the center button. Turn this on if you are providing an action for the center button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_left_long_loop: !input button_left_long_loop\n  button_left_long_max_loop_repeats: !input button_left_long_max_loop_repeats\n  button_left_double_press: !input button_left_double_press\n  button_right_long_loop: !input button_right_long_loop\n  button_right_long_max_loop_repeats: !input button_right_long_max_loop_repeats\n  button_right_double_press: !input button_right_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  button_center_double_press: !input button_center_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_left_short: ['4002']\n      button_left_long: ['4001']\n      button_left_release: ['4003']\n      button_right_short: ['5002']\n      button_right_long: ['5001']\n      button_right_release: ['5003']\n      button_up_short: ['2002']\n      button_up_long: ['2001']\n      button_up_release: ['2003']\n      button_down_short: ['3002']\n      button_down_long: ['3001']\n      button_down_release: ['3003']\n      button_center_short: ['1002']\n      button_center_long: ['1001']\n    zha:\n      button_left_short: [press_257_13_0]\n      button_left_long: [hold_3329_0]\n      button_left_release: [release]\n      button_right_short: [press_256_13_0]\n      button_right_long: [hold_3328_0]\n      button_right_release: [release]\n      button_up_short: [step_with_on_off_0_43_5]\n      button_up_long: [move_with_on_off_0_83, move_with_on_off_0_84]\n      button_up_release: [stop]\n      button_down_short: [step_1_43_5]\n      button_down_long: [move_1_83, move_1_84]\n      button_down_release: [stop]\n      button_center_short: [toggle]\n      button_center_long: [press_2_0_0]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1524_E1810.html#ikea-e1524-e1810\n      button_left_short: [arrow_left_click]\n      button_left_long: [arrow_left_hold]\n      button_left_release: [arrow_left_release]\n      button_right_short: [arrow_right_click]\n      button_right_long: [arrow_right_hold]\n      button_right_release: [arrow_right_release]\n      button_up_short: [brightness_up_click]\n      button_up_long: [brightness_up_hold]\n      button_up_release: [brightness_up_release]\n      button_down_short: [brightness_down_click]\n      button_down_long: [brightness_down_hold]\n      button_down_release: [brightness_down_release]\n      button_center_short: [toggle]\n      button_center_long: [toggle_hold]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_left_short: '{{ actions_mapping[integration_id][\"button_left_short\"] }}'\n  button_left_long: '{{ actions_mapping[integration_id][\"button_left_long\"] }}'\n  button_left_release: '{{ actions_mapping[integration_id][\"button_left_release\"] }}'\n  button_right_short: '{{ actions_mapping[integration_id][\"button_right_short\"] }}'\n  button_right_long: '{{ actions_mapping[integration_id][\"button_right_long\"] }}'\n  button_right_release: '{{ actions_mapping[integration_id][\"button_right_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  button_center_short: '{{ actions_mapping[integration_id][\"button_center_short\"] }}'\n  button_center_long: '{{ actions_mapping[integration_id][\"button_center_long\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_up_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_down_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle_hold\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_left_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_left_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_left\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_left_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_left_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_left_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_left_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_left_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_left_short\n      - conditions: '{{ trigger_action | string in button_left_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_left_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_left_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_left_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_left_long\n      - conditions:\n          - '{{ trigger_action | string in button_left_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_left_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_left_release\n      - conditions: '{{ trigger_action | string in button_right_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_right_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_right\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_right_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_right_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_right_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_right_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_right_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_right_short\n      - conditions: '{{ trigger_action | string in button_right_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_right_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_right_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_right_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_right_long\n      - conditions:\n          - '{{ trigger_action | string in button_right_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_right_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_right_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_up\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_down\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n      - conditions: '{{ trigger_action | string in button_center_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_center_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_center\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_center_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_center_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_center_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_center_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_center_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_center_short\n      - conditions: '{{ trigger_action | string in button_center_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_long\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_long\n"},2126:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation","title":"Automations","description":"Generic automation blueprints which cover different use-cases.","source":"@site/docs/blueprints/automation.mdx","sourceDirName":"blueprints","slug":"/blueprints/automation","permalink":"/awesome-ha-blueprints/docs/blueprints/automation","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation.mdx","tags":[],"version":"current","frontMatter":{"title":"Automations","description":"Generic automation blueprints which cover different use-cases."},"sidebar":"docs","previous":{"title":"Hooks","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Automations",description:"Generic automation blueprints which cover different use-cases."},a=void 0,d={},c=[];function u(e){const n={a:"a",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This category groups generic automation blueprints covering a wide range of different use-cases, not part of the ",(0,i.jsx)(n.a,{href:"controllers",children:"Controllers"}),"-",(0,i.jsx)(n.a,{href:"hooks",children:"Hooks"})," ecosystem."]}),"\n",(0,i.jsx)(s.VO,{category:"automation"})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},2219:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1744 SYMFONISK Rotary Remote\n  description: |\n    # Controller - IKEA E1744 SYMFONISK Rotary Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1744 SYMFONISK Rotary Remote. Allows to optionally loop a custom action during controller rotation.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1744/ikea_e1744.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1744.html#ikea-e1744\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 1\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 1 (E1744)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK Sound Controller\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK Sound Controller\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_rotate_left:\n      name: (Optional) Rotate left\n      description: Action to run on rotate left.\n      default: []\n      selector:\n        action:\n    action_rotate_left_stop:\n      name: (Optional) Rotate left stop\n      description: Action to run when stopping to rotate left the remote.\n      default: []\n      selector:\n        action:\n    action_rotate_right:\n      name: (Optional) Rotate right\n      description: Action to run on rotate right.\n      default: []\n      selector:\n        action:\n    action_rotate_right_stop:\n      name: (Optional) Rotate right stop\n      description: Action to run when stopping to rotate right the remote.\n      default: []\n      selector:\n        action:\n    action_click_short:\n      name: (Optional) Remote short press\n      description: Action to run on short remote press.\n      default: []\n      selector:\n        action:\n    action_click_double:\n      name: (Optional) Remote double press\n      description: Action to run on double remote press.\n      default: []\n      selector:\n        action:\n    action_click_triple:\n      name: (Optional) Remote triple press\n      description: Action to run on triple remote press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    rotate_left_loop:\n      name: (Optional) Rotate left - loop until stop\n      description: Loop the rotate left action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_left_max_loop_repeats:\n      name: (Optional) Rotate left - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    rotate_right_loop:\n      name: (Optional) Rotate right - loop until stop\n      description: Loop the rotate right action until the rotation is stopped.\n      default: false\n      selector:\n        boolean:\n    rotate_right_max_loop_repeats:\n      name: (Optional) Rotate right - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  rotate_left_loop: !input rotate_left_loop\n  rotate_left_max_loop_repeats: !input rotate_left_max_loop_repeats\n  rotate_right_loop: !input rotate_right_loop\n  rotate_right_max_loop_repeats: !input rotate_right_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      rotate_left: ['3001']\n      rotate_stop: ['3003', '2003']\n      rotate_right: ['2001']\n      click_short: ['1002']\n      click_double: ['1004']\n      click_triple: ['1005']\n    zha:\n      rotate_left: [move_1_195, move_MoveMode.Down_195_0_0]\n      rotate_stop: [stop, stop_0_0]\n      rotate_right: [move_0_195, move_MoveMode.Up_195_0_0]\n      click_short: [toggle]\n      click_double: [step_0_1_0, step_StepMode.Up_1_0_0_0]\n      click_triple: [step_1_1_0, step_StepMode.Down_1_0_0_0]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1744.html#ikea-e1744\n      rotate_left: [brightness_move_down]\n      rotate_stop: [brightness_stop]\n      rotate_right: [brightness_move_up]\n      click_short: [toggle]\n      click_double: [brightness_step_up]\n      click_triple: [brightness_step_down]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  rotate_left: '{{ actions_mapping[integration_id][\"rotate_left\"] }}'\n  rotate_stop: '{{ actions_mapping[integration_id][\"rotate_stop\"] }}'\n  rotate_right: '{{ actions_mapping[integration_id][\"rotate_right\"] }}'\n  click_short: '{{ actions_mapping[integration_id][\"click_short\"] }}'\n  click_double: '{{ actions_mapping[integration_id][\"click_double\"] }}'\n  click_triple: '{{ actions_mapping[integration_id][\"click_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_down\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{\\s*((\\\"a\\\":\\s*\\\".*\\\"|\\\"t\\\":\\s*\\d+\\.\\d+)(,\\s*)?){2}\\s*\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{\\s*((\\\"a\\\":\\s*\\\".*\\\"|\\\"t\\\":\\s*\\d+\\.\\d+)(,\\s*)?){2}\\s*\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in rotate_left }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ rotate_left_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < rotate_left_max_loop_repeats | int }}'\n                      sequence: !input action_rotate_left\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_left\n      - conditions:\n          - '{{ trigger_action | string in rotate_stop }}'\n          # check the previous event to determine the event which the received stop action is relative to\n          - '{{ last_controller_event | string in rotate_left }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left_stop\n      - conditions: '{{ trigger_action | string in rotate_right }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ rotate_right_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < rotate_right_max_loop_repeats | int }}'\n                      sequence: !input action_rotate_right\n            # if looping is not enabled run the custom action only once\n            default: !input action_rotate_right\n      - conditions:\n          - '{{ trigger_action | string in rotate_stop }}'\n          # check the previous event to determine the event which the received stop action is relative to\n          - '{{ last_controller_event | string in rotate_right }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right_stop\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right_stop\n      - conditions: '{{ trigger_action | string in click_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_short\n      - conditions: '{{ trigger_action | string in click_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_double\n      - conditions: '{{ trigger_action | string in click_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_triple\n"},2429:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg11lm/xiaomi_wxcjkg11lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG11LM.html#aqara-wxcjkg11lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (single band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (single band) (WXCJKG11LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Aqara Opple 2-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 2-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG11LM.html#aqara-wxcjkg11lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n"},2478:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/philips_8718699693985","title":"Controller - Philips 8718699693985 Hue Smart Button","description":"Controller automation for executing any kind of action triggered by the provided Philips 8718699693985 Hue Smart Button. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/philips_8718699693985.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/philips_8718699693985","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/philips_8718699693985.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Philips 8718699693985 Hue Smart Button","description":"Controller automation for executing any kind of action triggered by the provided Philips 8718699693985 Hue Smart Button. Supports Zigbee2MQTT, ZHA, deCONZ.","model":8718699693985,"manufacturer":"Philips","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"Philips 8718699693985 Hue Smart Button"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Philips 8718699693985 Hue Smart Button",description:"Controller automation for executing any kind of action triggered by the provided Philips 8718699693985 Hue Smart Button. Supports Zigbee2MQTT, ZHA, deCONZ.",model:8718699693985,manufacturer:"Philips",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"Philips 8718699693985 Hue Smart Button"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"philips_8718699693985",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Philips 8718699693985 Hue Smart Button. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_8718699693985#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"philips_8718699693985"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Toggle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Play/Pause"}),"\n",(0,i.jsxs)(n.li,{children:["Button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-14"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-05"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Added support for Zigbee2MQTT. (",(0,i.jsx)(n.a,{href:"https://github.com/alexdelprete",children:"@alexdelprete"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Fix regex for updated helper JSON serialization starting from Home Assistant 2023.5.0."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},2554:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/xiaomi_wxcjkg12lm","title":"Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/xiaomi_wxcjkg12lm.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/xiaomi_wxcjkg12lm","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/xiaomi_wxcjkg12lm.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"WXCJKG12LM","manufacturer":"Xiaomi","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"Xiaomi WXCJKG12LM Aqara Opple 4 button remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote",description:"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"WXCJKG12LM",manufacturer:"Xiaomi",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"Xiaomi WXCJKG12LM Aqara Opple 4 button remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Mapping #2",id:"mapping-2-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Mapping #2",id:"mapping-2-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"xiaomi_wxcjkg12lm",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg12lm#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"xiaomi_wxcjkg12lm"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2-1",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},2625:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Send Web UI persistent notifications to Mobile Devices\n  description: |\n    # Send Web UI persistent notifications to Mobile Devices\n\n    Send Web UI persistent notifications with the provided ID to the specified Mobile Devices.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/persistent_notification_to_mobile).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/persistent_notification_to_mobile/persistent_notification_to_mobile.yaml\n  domain: automation\n  input:\n    notification_id:\n      name: (Optional) Notification ID\n      description: The notification ID of persistent notifications which must be sent to mobile devices. Empty for all notifications.\n      default: ''\n      selector:\n        text:\n    mobile_notify_service:\n      name: (Required) Mobile devices notification service\n      description: >-\n        The notification service for mobile devices (eg. service.mobile_app_<your_device_id_here>).\n        You can provide both a notify group or a single notify device here.\n      selector:\n        text:\n    replace_notifications:\n      name: (Optional) Replace notifications with same ID\n      description: Replace existing notifications with the same notification ID.\n      default: false\n      selector:\n        boolean:\n    android_notification_channel:\n      name: (Optional) (Android only) Notification channel\n      description: >-\n        Android notification channel. Allows to group notifications to\n        then apply custom settings for sound, vibration, etc. Leave blank if you do\n        not want to use this feature.\n      default: ''\n      selector:\n        text:\n    notification_group:\n      name: (Optional) Notification group\n      description: >-\n        Notification group for the notifications sent with this automation.\n        Use this to group notifications in the notification tray. Leave blank if you\n        do not want to use this feature.\n      default: ''\n      selector:\n        text:\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  notification_id: !input notification_id\n  replace_notifications: !input replace_notifications\nmode: queued\nmax: 10\nmax_exceeded: silent\n\n# trigger when a persistent notification has been created\ntrigger:\n  platform: event\n  event_type: call_service\n  event_data:\n    domain: persistent_notification\n    service: create\ncondition:\n  # check whether the persistent notification id matches the one provided by the user\n  # skip the check if the field is blank.\n  condition: template\n  value_template: '{{ trigger.event.data.service_data.notification_id == notification_id or notification_id == \"\" }}'\naction:\n  # send a notification to mobile devices with the content of the persistent notification\n  - service: !input mobile_notify_service\n    data:\n      title: '{{ trigger.event.data.service_data.title }}'\n      message: '{{ trigger.event.data.service_data.message }}'\n      data:\n        # Android replace notifications, notification group and notification channel\n        tag: '{{ trigger.event.data.service_data.notification_id if replace_notifications else \"\" }}'\n        group: !input notification_group\n        channel: !input android_notification_channel\n        # iOS notification group\n        push:\n          thread-id: !input notification_group\n        # iOS replace notifications\n        apns_headers:\n          apns-collapse-id: '{{ trigger.event.data.service_data.notification_id if replace_notifications else \"\" }}'\n"},2703:e=>{"use strict";e.exports="# Blueprint Metadata\nblueprint:\n  name: Controller - IKEA E2123 SYMFONISK sound remote, gen 2\n  description: |\n    # Controller - IKEA E2123 SYMFONISK sound remote, gen 2\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2123 SYMFONISK sound remote, gen 2.\n\n    Supports Zigbee2MQTT, ZHA, deCONZ.\n\n    The blueprint handles double button press events natively for the dots1/dots2 buttons as it is supported by the controller device itself.\n    Long and Double press events can be enabled/disabled for each of the dots1/dots2 buttons to get extra speed in recognizing single press events.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with lights, covers, media players, and potentially more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2123#available-hooks) for additional details.\n\n    This blueprint is only compatible with firmwares 1.0.32 (20221219) and 1.0.35 (20230308) of the IKEA E2123 SYMFONISK sound remote, gen 2.\n\n    A small note, avoid using both custom actions and Hooks in the same blueprint, otherwise strange things may occur.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.28\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2123/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2123).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2123/ikea_e2123.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  # Device Selector\n  input:\n    controller_device:\n      name: (Required) (Zigbee2MQTT, ZHA, deCONZ) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with Zigbee2MQTT, ZHA, deCONZ.\n      default: ''\n      selector:\n        # source: https://zigbee.blakadder.com/Ikea_E2123.html\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2123.html\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 2\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SYMFONISK sound remote, gen 2 (E2123)\n            # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/symfonisk2.py\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK sound remote gen2\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/master/devices/ikea/symfonisk_sound_remote_gen2.json\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: SYMFONISK sound remote gen2\n          multiple: false\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_right_short:\n      name: (Optional) Right button short press\n      description: Action to run on short right button press.\n      default: []\n      selector:\n        action:\n    action_button_left_short:\n      name: (Optional) Left button short press\n      description: Action to run on short left button press.\n      default: []\n      selector:\n        action:\n    action_button_center_short:\n      name: (Optional) Center button short press\n      description: Action to run on short center button press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_short:\n      name: (Optional) Dots1 button short press\n      description: Action to run on short dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_long:\n      name: (Optional) Dots1 button long press\n      description: Action to run on long dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_release:\n      name: (Optional) Dots1 button release\n      description: Action to run on dots1 button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_double:\n      name: (Optional) Dots1 button double press\n      description: Action to run on double dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_short:\n      name: (Optional) Dots2 button short press\n      description: Action to run on short dots2 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_long:\n      name: (Optional) Dots2 button long press\n      description: Action to run on long dots2 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_release:\n      name: (Optional) Dots2 button release\n      description: Action to run on dots2 button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_double:\n      name: (Optional) Dots2 button double press\n      description: Action to run on double dots2 button press.\n      default: []\n      selector:\n        action:\n    # Special inputs for dots1/dots2 Long/Double press actions to enable or disable\n    dots12_special_options_section:\n      name: Dots1 and Dots2 Long/Double Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_dots1_longdouble_enabled:\n          name: (Optional) Dots1 button Long/Double press - enable/disable\n          description: Enable the Dots1 button \u201cLong Press\u201d and \u201cDouble Press\u201d actions. Disable to remove delay from \u201cSingle Press\u201d actions.\n          default: true\n          selector:\n            boolean:\n        button_dots2_longdouble_enabled:\n          name: (Optional) Dots2 button Long/Double press - enable/disable\n          description: Enable the Dots2 button \u201cLong Press\u201d and \u201cDouble Press\u201d actions. Disable to remove delay from \u201cSingle Press\u201d actions.\n          default: true\n          selector:\n            boolean:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    long_press_options_section:\n      name: Long Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_up_long_loop:\n          name: (Optional) Up button long press - loop until release\n          description: Loop the up button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_up_long_max_loop_repeats:\n          name: (Optional) Up button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_down_long_loop:\n          name: (Optional) Down button long press - loop until release\n          description: Loop the down button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_down_long_max_loop_repeats:\n          name: (Optional) Down button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_right_long_loop:\n          name: (Optional) Right button long press - loop until release\n          description: Loop the right button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_right_long_max_loop_repeats:\n          name: (Optional) Right button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_left_long_loop:\n          name: (Optional) Left button long press - loop until release\n          description: Loop the left button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_left_long_max_loop_repeats:\n          name: (Optional) Left button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_center_long_loop:\n          name: (Optional) Center button long press - loop until release\n          description: Loop the center button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_center_long_max_loop_repeats:\n          name: (Optional) Center button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_dots1_long_loop:\n          name: (Optional) Dots1 button long press - loop until release\n          description: Loop the dots1 button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_dots1_long_max_loop_repeats:\n          name: (Optional) Dots1 button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_dots2_long_loop:\n          name: (Optional) Dots2 button long press - loop until release\n          description: Loop the dots2 button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_dots2_long_max_loop_repeats:\n          name: (Optional) Dots2 button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        helper_long_press_delay:\n          name: (Optional) Helper - Long Press delay\n          description: Max delay between the pushing and releasing of a button long press event. Increase this value if you notice that the long press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n#\n# Automation schema\nvariables:\n  # Controller ID\n  controller_id: !input controller_device\n  # integration id used to select items in the action mapping\n  # integration type is set from trigger.id\n  integration_id: '{{ trigger.id.split(\"-\")[0] }}'\n  # convert input tags to variables, to be used in templates\n  button_dots1_longdouble_enabled: !input button_dots1_longdouble_enabled\n  button_dots2_longdouble_enabled: !input button_dots2_longdouble_enabled\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_right_long_loop: !input button_right_long_loop\n  button_right_long_max_loop_repeats: !input button_right_long_max_loop_repeats\n  button_left_long_loop: !input button_left_long_loop\n  button_left_long_max_loop_repeats: !input button_left_long_max_loop_repeats\n  button_center_long_loop: !input button_center_long_loop\n  button_center_long_max_loop_repeats: !input button_center_long_max_loop_repeats\n  button_dots1_long_loop: !input button_dots1_long_loop\n  button_dots1_long_max_loop_repeats: !input button_dots1_long_max_loop_repeats\n  button_dots2_long_loop: !input button_dots2_long_loop\n  button_dots2_long_max_loop_repeats: !input button_dots2_long_max_loop_repeats\n  helper_long_press_delay: !input helper_long_press_delay\n  # mapping between actions and integrations\n  actions_mapping:\n    z2m:\n      # source: https://www.zigbee2mqtt.io/devices/E2123.html\n      button_up_short: [volume_up]\n      button_up_long: [volume_up_hold]\n      button_down_short: [volume_down]\n      button_down_long: [volume_down_hold]\n      button_right_short: [track_next]\n      button_left_short: [track_previous]\n      button_center_short: [toggle, play_pause]\n      button_dots1_short: [dots_1_initial_press, dots_1_short_release]\n      button_dots1_long: [dots_1_long_press]\n      button_dots1_release: [dots_1_long_release]\n      button_dots1_double: [dots_1_double_press]\n      button_dots2_short: [dots_2_initial_press, dots_2_short_release]\n      button_dots2_long: [dots_2_long_press]\n      button_dots2_release: [dots_2_long_release]\n      button_dots2_double: [dots_2_double_press]\n    zha:\n      # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/symfonisk2.py\n      button_up_short: [move_on_off_8_1_0]\n      button_up_long: [move_8_1]\n      button_down_short: [move_on_off_8_1_1]\n      button_down_long: [move_8_1_1]\n      button_right_short: [step_8_1_0]\n      button_left_short: [step_8_1_1]\n      button_center_short: [toggle_6_1]\n      button_dots1_short: [initial_press_2, short_release_2]\n      button_dots1_long: [long_press_2]\n      button_dots1_release: [long_release_2]\n      button_dots1_double: [multi_press_complete_2]\n      button_dots2_short: [initial_press_3, short_release_3]\n      button_dots2_long: [long_press_3]\n      button_dots2_release: [long_release_3]\n      button_dots2_double: [multi_press_complete_3]\n    dcz:\n      # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/master/devices/ikea/symfonisk_sound_remote_gen2.json\n      button_up_short: ['2001']\n      button_up_long: ['2002']\n      button_down_short: ['3001']\n      button_down_long: ['3002']\n      button_right_short: ['5002']\n      button_left_short: ['4002']\n      button_center_short: ['1002']\n      button_dots1_short: ['6001', '6003']\n      button_dots1_long: ['6002']\n      button_dots1_release: ['6004']\n      button_dots1_double: ['6006']\n      button_dots2_short: ['7001', '7003']\n      button_dots2_long: ['7002']\n      button_dots2_release: ['7004']\n      button_dots2_double: ['7006']\n  # pre-choose actions for buttons based on configured integration\n  # mainly used to pass to hooks through ahb_controller_event\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_right_short: '{{ actions_mapping[integration_id][\"button_right_short\"] }}'\n  button_left_short: '{{ actions_mapping[integration_id][\"button_left_short\"] }}'\n  button_center_short: '{{ actions_mapping[integration_id][\"button_center_short\"] }}'\n  button_dots1_short: '{{ actions_mapping[integration_id][\"button_dots1_short\"] }}'\n  button_dots1_long: '{{ actions_mapping[integration_id][\"button_dots1_long\"] }}'\n  button_dots1_release: '{{ actions_mapping[integration_id][\"button_dots1_release\"] }}'\n  button_dots1_double: '{{ actions_mapping[integration_id][\"button_dots1_double\"] }}'\n  button_dots2_short: '{{ actions_mapping[integration_id][\"button_dots2_short\"] }}'\n  button_dots2_long: '{{ actions_mapping[integration_id][\"button_dots2_long\"] }}'\n  button_dots2_release: '{{ actions_mapping[integration_id][\"button_dots2_release\"] }}'\n  button_dots2_double: '{{ actions_mapping[integration_id][\"button_dots2_double\"] }}'\n#\n# Mode Block\nmode: single\nmax_exceeded: silent\n#\n# Triggers Block\ntriggers:\n  # triggers for zigbee2mqtt\n  # Up Button\n  - trigger: device\n    id: z2m-button-up-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: volume_up\n  - trigger: device\n    id: z2m-button-up-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: volume_up_hold\n  # Down Button\n  - trigger: device\n    id: z2m-button-down-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: volume_down\n  - trigger: device\n    id: z2m-button-down-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: volume_down_hold\n  # Right Button\n  - trigger: device\n    id: z2m-button-right-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: track_next\n  # Left Button\n  - trigger: device\n    id: z2m-button-left-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: track_previous\n  # Center Button (Two actions firmware <=1.0.32 toggle - firmware 1.0.35 play_pause)\n  - trigger: device\n    id: z2m-button-center-playpause\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: play_pause\n  - trigger: device\n    id: z2m-button-center-toggle\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  # Dots1 Button\n  - trigger: device\n    id: z2m-button-dots1-initial\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_1_initial_press\n  - trigger: device\n    id: z2m-button-dots1-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_1_short_release\n  - trigger: device\n    id: z2m-button-dots1-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_1_long_press\n  - trigger: device\n    id: z2m-button-dots1-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_1_long_release\n  - trigger: device\n    id: z2m-button-dots1-double\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_1_double_press\n  # Dots2 Button\n  - trigger: device\n    id: z2m-button-dots2-initial\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_2_initial_press\n  - trigger: device\n    id: z2m-button-dots2-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_2_short_release\n  - trigger: device\n    id: z2m-button-dots2-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_2_long_press\n  - trigger: device\n    id: z2m-button-dots2-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_2_long_release\n  - trigger: device\n    id: z2m-button-dots2-double\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: dots_2_double_press\n  # triggers for ZHA\n  # Up Button\n  - trigger: event\n    id: zha-button-up-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move_on_off\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0]\n  - trigger: event\n    id: zha-button-up-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0]\n  # Down Button\n  - trigger: event\n    id: zha-button-down-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move_on_off\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1]\n  - trigger: event\n    id: zha-button-down-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1]\n  # Right Button\n  - trigger: event\n    id: zha-button-right-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0]\n  # Left Button\n  - trigger: event\n    id: zha-button-left-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1]\n  # Center Button\n  - trigger: event\n    id: zha-button-center-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: toggle\n      endpoint_id: 1\n      cluster_id: 6\n  # Dots1 Button\n  - trigger: event\n    id: zha-button-dots1-initial\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: initial_press\n      endpoint_id: 2\n  - trigger: event\n    id: zha-button-dots1-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: short_release\n      endpoint_id: 2\n  - trigger: event\n    id: zha-button-dots1-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_press\n      endpoint_id: 2\n  - trigger: event\n    id: zha-button-dots1-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_release\n      endpoint_id: 2\n  - trigger: event\n    id: zha-button-dots1-double\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: multi_press_complete\n      endpoint_id: 2\n  # Dots2 Button\n  - trigger: event\n    id: zha-button-dots2-initial\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: initial_press\n      endpoint_id: 3\n  - trigger: event\n    id: zha-button-dots2-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: short_release\n      endpoint_id: 3\n  - trigger: event\n    id: zha-button-dots2-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_press\n      endpoint_id: 3\n  - trigger: event\n    id: zha-button-dots2-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_release\n      endpoint_id: 3\n  - trigger: event\n    id: zha-button-dots2-double\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: multi_press_complete\n      endpoint_id: 3\n  # triggers for deCONZ\n  # Up Button\n  - trigger: event\n    id: dcz-button-up-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2001'\n  - trigger: event\n    id: dcz-button-up-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2002'\n  # Down Button\n  - trigger: event\n    id: dcz-button-down-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '3001'\n  - trigger: event\n    id: dcz-button-down-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '3002'\n  # Right Button\n  - trigger: event\n    id: dcz-button-right-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '5002'\n  # Left Button\n  - trigger: event\n    id: dcz-button-left-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '4002'\n  # Center Button\n  - trigger: event\n    id: dcz-button-center-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1002'\n  # Dots1 Button\n  - trigger: event\n    id: dcz-button-dots1-initial\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '6001'\n  - trigger: event\n    id: dcz-button-dots1-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '6003'\n  - trigger: event\n    id: dcz-button-dots1-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '6002'\n  - trigger: event\n    id: dcz-button-dots1-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '6004'\n  - trigger: event\n    id: dcz-button-dots1-double\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '6006'\n  # Dots1 Button\n  - trigger: event\n    id: dcz-button-dots2-initial\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '7001'\n  - trigger: event\n    id: dcz-button-dots2-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '7003'\n  - trigger: event\n    id: dcz-button-dots2-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '7002'\n  - trigger: event\n    id: dcz-button-dots2-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '7004'\n  - trigger: event\n    id: dcz-button-dots2-double\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '7006'\n#\n# Conditions Block\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"z2m\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- elif integration_id == \"dcz\" -%}\n        {{ trigger.event.data.event }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\n#\n# Actions Block\nactions:\n  #\n  # Actions for Center Button single press zigbee2mqtt (Firmware 1.0.35 play_pause instead of toggle)\n  - choose:\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-center-playpause\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_short\n  #\n  # Actions for Dots1/Dots2 initial_press events if initial press enabled\n  - choose:\n      #\n      # Actions for Dots1 Button initial press\n      - conditions:\n          - '{{ not button_dots1_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots1-initial\n              - zha-button-dots1-initial\n              - dcz-button-dots1-initial\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_short\n      #\n      # Actions for Dots2 Button initial press\n      - conditions:\n          - '{{ not button_dots2_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots2-initial\n              - zha-button-dots2-initial\n              - dcz-button-dots2-initial\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_short\n  #\n  # Actions for all remaining actions not captured above\n  - choose:\n      #\n      # Actions for Up Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-short\n              - zha-button-up-short\n              - dcz-button-up-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_short\n      #\n      # Actions for Up Button Long Press No Release\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-long\n              - zha-button-up-long\n              - dcz-button-up-long\n        sequence:\n          # fire the ahb hook event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the custom action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      #\n      # Actions for Down Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-short\n              - zha-button-down-short\n              - dcz-button-down-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_short\n      #\n      # Actions for Down Button Long Press No Release\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-long\n              - zha-button-down-long\n              - dcz-button-down-long\n        sequence:\n          # fire the ahb hook event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the custom action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      #\n      # Actions for Right Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-right-short\n              - zha-button-right-short\n              - dcz-button-right-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_right_short\n      #\n      # Actions for Left Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-left-short\n              - zha-button-left-short\n              - dcz-button-left-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_left_short\n      #\n      # Actions for Center Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-center-toggle\n              - zha-button-center-short\n              - dcz-button-center-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_center_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_center_short\n      #\n      # Actions for Dots1 Button single press\n      - conditions:\n          - '{{ button_dots1_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots1-short\n              - zha-button-dots1-short\n              - dcz-button-dots1-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_short\n      #\n      # Actions for Dots1 Button Long Press\n      - conditions:\n          - '{{ button_dots1_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots1-long\n              - zha-button-dots1-long\n              - dcz-button-dots1-long\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_long\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_long\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ button_dots1_long_loop }}'\n                sequence:\n                  # Repeat the Long Press Actions for the set number of loops\n                  - repeat:\n                      count: !input button_dots1_long_max_loop_repeats\n                      sequence:\n                        - parallel:\n                            - sequence: !input action_button_dots1_long\n                            - sequence:\n                                - choose:\n                                    - conditions: []\n                                      sequence:\n                                        # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                                        - wait_for_trigger:\n                                            # z2m triggers\n                                            - trigger: device\n                                              domain: mqtt\n                                              device_id: !input controller_device\n                                              type: action\n                                              subtype: dots_1_long_release\n                                            # zha triggers\n                                            - trigger: event\n                                              event_type: zha_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                command: long_release\n                                                endpoint_id: 2\n                                            # dcz triggers\n                                            - trigger: event\n                                              event_type: deconz_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                event: '6004'\n                                          timeout:\n                                            milliseconds: !input helper_long_press_delay\n                                          continue_on_timeout: true\n                                        # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                        - if:\n                                            - condition: template\n                                              value_template: '{{ wait.trigger.idx is defined }}'\n                                          then:\n                                            # fire the event\n                                            - event: ahb_controller_event\n                                              event_data:\n                                                controller: '{{ controller_id }}'\n                                                action: button_dots1_release\n                                            # run the custom action\n                                            - choose:\n                                                - conditions: []\n                                                  sequence: !input action_button_dots1_release\n                                            # Stop the repeat loop\n                                            - stop: button_dots1_released\n      #\n      # Actions for Dots1 Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots1-release\n              - zha-button-dots1-release\n              - dcz-button-dots1-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_release\n      #\n      # Actions for Dots1 Button double press\n      - conditions:\n          - '{{ button_dots1_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots1-double\n              - zha-button-dots1-double\n              - dcz-button-dots1-double\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_double\n      #\n      # Actions for Dots2 Button single press\n      - conditions:\n          - '{{ button_dots2_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots2-short\n              - zha-button-dots2-short\n              - dcz-button-dots2-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_short\n      #\n      # Actions for Dots2 Button Long Press\n      - conditions:\n          - '{{ button_dots2_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots2-long\n              - zha-button-dots2-long\n              - dcz-button-dots2-long\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_long\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_long\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ button_dots2_long_loop }}'\n                sequence:\n                  # Repeat the Long Press Actions for the set number of loops\n                  - repeat:\n                      count: !input button_dots2_long_max_loop_repeats\n                      sequence:\n                        - parallel:\n                            - sequence: !input action_button_dots2_long\n                            - sequence:\n                                - choose:\n                                    - conditions: []\n                                      # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                                      sequence:\n                                        - wait_for_trigger:\n                                            # z2m triggers\n                                            - trigger: device\n                                              domain: mqtt\n                                              device_id: !input controller_device\n                                              type: action\n                                              subtype: dots_2_long_release\n                                            # zha triggers\n                                            - trigger: event\n                                              event_type: zha_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                command: long_release\n                                                endpoint_id: 3\n                                            # dcz triggers\n                                            - trigger: event\n                                              event_type: deconz_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                event: '7004'\n                                          timeout:\n                                            milliseconds: !input helper_long_press_delay\n                                          continue_on_timeout: true\n                                        # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                        - if:\n                                            - condition: template\n                                              value_template: '{{ wait.trigger.idx is defined }}'\n                                          then:\n                                            # fire the event\n                                            - event: ahb_controller_event\n                                              event_data:\n                                                controller: '{{ controller_id }}'\n                                                action: button_dots2_release\n                                            # run the custom action\n                                            - choose:\n                                                - conditions: []\n                                                  sequence: !input action_button_dots2_release\n                                            # Stop the repeat loop\n                                            - stop: button_dots2_released\n      #\n      # Actions for Dots2 Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots2-release\n              - zha-button-dots2-release\n              - dcz-button-dots2-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_release\n      #\n      # Actions for Dots2 Button double press\n      - conditions:\n          - '{{ button_dots2_longdouble_enabled }}'\n          - condition: trigger\n            id:\n              - z2m-button-dots2-double\n              - zha-button-dots2-double\n              - dcz-button-dots2-double\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_double\n"},2761:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Send a mobile notification when add-on update is available\n  description: |\n    # Send a mobile notification when add-on update is available\n\n    Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available.\n    Supports full notification customization, notification groups, auto-dismissal when the add-on is updated and button for starting the update directly from your notification tray,\n    with optional notification after the update completed succesfully.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/addon_update_notification).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/addon_update_notification/addon_update_notification.yaml\n  domain: automation\n  input:\n    addon:\n      name: (Required) Add-on\n      description: The add-on to monitor for updates.\n      selector:\n        addon:\n    addon_name:\n      name: (Required) Add-on name\n      description: The add-on name to be displayed in notifications.\n      selector:\n        text:\n    addon_sensor_version:\n      name: (Required) Add-on version sensor\n      description: The add-on current version sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: sensor\n          integration: hassio\n    addon_sensor_newest_version:\n      name: (Required) Add-on newest version sensor\n      description: The add-on newest version sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: sensor\n          integration: hassio\n    addon_sensor_update_available:\n      name: (Required) Add-on update available sensor\n      description: The add-on update available sensor, exposed by the Supervisor.\n      selector:\n        entity:\n          domain: binary_sensor\n          integration: hassio\n    mobile_notify_service:\n      name: (Required) Mobile devices notification service\n      description: >-\n        The notification service for mobile devices (eg. service.mobile_app_<your_device_id_here>).\n        You can provide both a notify group or a single notify device here.\n      selector:\n        text:\n    notification_title:\n      name: (Optional) Notification title\n      description: >-\n        Title for the update notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: '{{ addon_name }} add-on : Update available'\n      selector:\n        text:\n    notification_message:\n      name: (Optional) Notification message\n      description: >-\n        Message for the update notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: Update available for {{ addon_name }} add-on ({{ version }} -> {{ newest_version }})\n      selector:\n        text:\n          multiline: true\n    tap_action:\n      name: (Optional) Tap action\n      description: URL you will navigate to when tapping on the notification. Default to the add-on info page.\n      default: /hassio/addon/{{ addon }}/info\n      selector:\n        text:\n    notification_color:\n      name: (Optional) (Android only) Notification color\n      description: Color for the notifications. You can both type a friendly color name or an hex value.\n      default: ''\n      selector:\n        text:\n    notification_channel:\n      name: (Optional) (Android only) Notification channel\n      description: >-\n        Android notification channel. Allows to group notifications to\n        then apply custom settings for sound, vibration, etc. Leave blank if you do\n        not want to use this feature.\n      default: ''\n      selector:\n        text:\n    notification_channel_importance:\n      name: (Optional) (Android only) Notification Channel importance\n      description: Android notification channel importance. Allows to define different priority levels for your notifications.\n      default: default\n      selector:\n        select:\n          options:\n            - default\n            - min\n            - low\n            - high\n            - max\n    notification_group:\n      name: (Optional) Notification group\n      description: >-\n        Notification group for the notifications sent with this automation.\n        Use this to group notifications in the notification tray. Leave blank if you\n        do not want to use this feature.\n      default: ''\n      selector:\n        text:\n    update_button:\n      name: (Optional) Notification Update Button\n      description: Add a button to the notification for updating the add-on.\n      default: true\n      selector:\n        boolean:\n    update_success_notification:\n      name: (Optional) Update success notification\n      description: >-\n        Send a notification after the add-on update triggered by the update button succeed.\n        The notification will use the same settings for group, channel, importance and color from the update available notification.\n      default: true\n      selector:\n        boolean:\n    update_success_notification_title:\n      name: (Optional) Update success notification title\n      description: >-\n        Title for the update success notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: '{{ addon_name }} add-on: Update completed'\n      selector:\n        text:\n    update_success_notification_message:\n      name: (Optional) Update success notification message\n      description: >-\n        Message for the update success notification.\n        You can use {{ version }}, {{ newest_version }}, and {{ addon_name }} templates to include add-on current version, newest version and name respectively.\n      default: Add-on {{ addon_name }} was succesfully updated to {{ newest_version }}\n      selector:\n        text:\n          multiline: true\n# Automation schema\nvariables:\n  # convert blueprint inputs to variables to be used in templates\n  notification_title: !input notification_title\n  notification_message: !input notification_message\n  addon: !input addon\n  addon_name: !input addon_name\n  addon_sensor_version: !input addon_sensor_version\n  addon_sensor_newest_version: !input addon_sensor_newest_version\n  addon_sensor_update_available: !input addon_sensor_update_available\n  update_button: !input update_button\n  update_success_notification: !input update_success_notification\ntrigger_variables:\n  trigger_addon: !input addon\n\nmode: single\nmax_exceeded: silent\ntrigger:\n  # trigger when the update status changes\n  - platform: state\n    entity_id: !input addon_sensor_update_available\n  # trigger when a user presses on the update button in the notification\n  - platform: event\n    event_type: mobile_app_notification_action\n    event_data:\n      tag: ahb_addon_notification_{{ trigger_addon }}\n      action: ahb_addon_update_{{ trigger_addon }}\naction:\n  - variables:\n      version: '{{ states(addon_sensor_version) }}'\n      newest_version: '{{ states(addon_sensor_newest_version) }}'\n  - choose:\n      # if an update was requested by the user clicking on the update button in the notification\n      - conditions: '{{ \"event\" in trigger and trigger.event.event_type == \"mobile_app_notification_action\" }}'\n        sequence:\n          # update the addon\n          - service: hassio.addon_update\n            data:\n              addon: !input addon\n          # if user opted in for notification after successful update, send it to the mobile device\n          - condition: template\n            value_template: '{{ update_success_notification }}'\n          - service: !input mobile_notify_service\n            data:\n              title: !input update_success_notification_title\n              message: !input update_success_notification_message\n              data:\n                # iOS URL\n                url: !input tap_action\n                # Android URL\n                clickAction: !input tap_action\n                tag: 'ahb_addon_notification_{{ addon }}'\n                # notification group\n                group: !input notification_group\n                channel: !input notification_channel\n                importance: !input notification_channel_importance\n                color: !input notification_color\n      # if an update is available send a notification\n      - conditions: '{{ trigger.to_state.state == \"on\" }}'\n        sequence:\n          - service: !input mobile_notify_service\n            data:\n              title: !input notification_title\n              message: !input notification_message\n              data:\n                # iOS URL\n                url: !input tap_action\n                # Android URL\n                clickAction: !input tap_action\n                tag: 'ahb_addon_notification_{{ addon }}'\n                # notification group\n                group: !input notification_group\n                channel: !input notification_channel\n                importance: !input notification_channel_importance\n                color: !input notification_color\n                actions: >-\n                  {% set actions=[{\"action\": \"ahb_addon_update_\"+addon, \"title\": \"Update\"}] %} {{ actions if update_button else [] }}\n    # if no update is available dismiss any previous update notification\n    default:\n      - service: !input mobile_notify_service\n        data:\n          message: 'clear_notification'\n          data:\n            tag: 'ahb_update_notification_{{ addon }}'\n"},2864:(e,n,t)=>{"use strict";t.d(n,{VO:()=>A,mV:()=>M,_x:()=>y,G0:()=>g,Kg:()=>f});var o=t(8225),i=t(7557);const r=e=>{let{variant:n,children:t}=e;return(0,i.jsx)("span",{className:`badge badge--${n}`,children:t})},s={action:{type:"Action"},addon:{type:"Add-on"},area:{type:"Area"},boolean:{type:"Boolean"},device:{type:"Device"},entity:{type:"Entity"},virtual:{type:"Virtual"},number:{type:"Number"},object:{type:"Object"},select:{type:"Select"},target:{type:"Target"},input_text:{type:"Text"},text:{type:"Text"},time:{type:"Time"},none:{type:"Text"}},l={input:{marginBottom:"1.25rem"},header:{display:"flex",justifyContent:"space-between",alignItems:"center",gap:"1rem",marginBottom:"0.5rem"},nameContainer:{display:"flex",flexWrap:"wrap",gap:"0.5rem",alignItems:"center"},name:{fontWeight:600,color:"var(--ifm-color-emphasis-900)"},badges:{display:"flex",fontSize:"0.975rem",alignItems:"flex-end",justifyContent:"flex-end",gap:"0.375rem",flexWrap:"wrap"},description:{margin:0,color:"var(--ifm-color-emphasis-700)",fontSize:"0.9375rem",lineHeight:1.5}},a=e=>{let{inputData:n}=e;const t=n.name.match(/\(([^)]*\s+)?Required\)/),o=n.name.replace("(Optional) ","").replace("(Required) ","").replace("(Deprecated) ","").replace("(Virtual) ","").replace(t?.[0]||"","").trim(),a=n.description,d=Object.keys(n.selector||{})[0]||"none",c=t?t[1]??" ":void 0,u=n.name.includes("(Deprecated)"),p=n.name.includes("(Virtual)"),h=d?s[d]:s.none;return(0,i.jsxs)("div",{style:l.input,children:[(0,i.jsxs)("div",{style:l.header,children:[(0,i.jsx)("div",{style:l.nameContainer,children:(0,i.jsx)("span",{style:l.name,children:o})}),(0,i.jsxs)("span",{style:l.badges,children:[(0,i.jsx)(r,{variant:"primary",children:h.type}),c?(0,i.jsxs)(r,{variant:"warning",children:[c," Required"]}):(0,i.jsx)(r,{variant:"info",children:"Optional"}),u&&(0,i.jsx)(r,{variant:"danger",children:"Deprecated"}),p&&(0,i.jsx)(r,{variant:"secondary",children:"Virtual"})]})]}),(0,i.jsx)("p",{style:l.description,children:a})]})},d=t(4655),c=t(7640);var u=t(3293),p=t(9113);const h={section:{marginBottom:"1.25rem"},header:{marginBottom:"1.5rem"},titleButton:{display:"flex",alignItems:"center",gap:"0.75rem",marginBottom:"0.5rem",padding:0,border:"none",background:"none",cursor:"pointer",width:"100%",textAlign:"left",transition:"opacity 0.2s ease"},titleButtonHover:{opacity:.7},icon:{fontSize:"1.25rem",color:"var(--ifm-color-emphasis-600)"},name:{fontSize:"1.25rem",fontWeight:700,color:"var(--ifm-color-emphasis-900)",margin:0,display:"flex",alignItems:"center",gap:"0.5rem"},chevron:{fontSize:"1rem",color:"var(--ifm-color-emphasis-500)",transition:"transform 0.2s ease"},chevronCollapsed:{transform:"rotate(-90deg)"},description:{margin:0,color:"var(--ifm-color-emphasis-700)",fontSize:"0.9375rem",lineHeight:1.5},content:{padding:"0.5rem 0 0 0.5rem",borderLeft:"2px solid var(--ifm-color-emphasis-200)",transition:"opacity 0.2s ease, transform 0.2s ease"},collapsedContent:{display:"none"},title:{display:"flex",alignItems:"center",gap:"0.75rem"}},_=e=>{let{name:n,description:t,collapsed:r=!1,input:s}=e;const[l,d]=(0,o.useState)(r),[c,u]=(0,o.useState)(!1);return(0,i.jsxs)("div",{style:h.section,children:[(0,i.jsxs)("div",{style:h.header,children:[(0,i.jsx)("button",{type:"button",style:{...h.titleButton,...c?h.titleButtonHover:{}},onClick:()=>d(!l),onMouseEnter:()=>u(!0),onMouseLeave:()=>u(!1),children:(0,i.jsx)("div",{style:h.title,children:(0,i.jsxs)("h3",{style:h.name,children:[n,(0,i.jsx)(p.A,{style:{...h.chevron,...l?h.chevronCollapsed:{}}})]})})}),t&&(0,i.jsx)("div",{style:h.description,children:t})]}),(0,i.jsx)("div",{style:{...h.content,...l?h.collapsedContent:{}},children:Object.entries(s).map((e=>{let[n,t]=e;return(0,i.jsx)(a,{inputData:t},n)}))})]})},g=e=>{let{category:n,id:t}=e;const[r,s]=(0,o.useState)({});return(0,o.useEffect)((()=>{try{const e=d(`./${n}/${t}/${t}.yaml`),o=u.Ay.parse(e);s(o.blueprint.input||{})}catch(e){console.error("Error fetching blueprint:",e),s({})}}),[n,t]),(0,i.jsx)("div",{className:"blueprint-inputs",children:Object.entries(r).map((e=>{let[n,t]=e;return"input"in t?(0,i.jsx)(_,{name:t.name,description:t.description,collapsed:t.collapsed,input:t.input},n):(0,i.jsx)(a,{inputData:t},n)}))})},b={requirementNameContainer:{paddingBottom:"0.8rem"},requirementName:{display:"inline"}},m=e=>{let{name:n,required:t,children:o}=e;return(0,i.jsxs)("div",{className:"margin-bottom--lg",children:[(0,i.jsxs)("div",{style:b.requirementNameContainer,children:[(0,i.jsxs)("h3",{style:b.requirementName,children:[n," "]}),t?(0,i.jsxs)(r,{variant:"warning",children:[t," Required"]}):(0,i.jsx)(r,{variant:"info",children:"Optional"})]}),o]})};const v={zigbee2mqtt:function(e){let{required:n,refers:t,children:o}=e;return(0,i.jsxs)(m,{name:"Zigbee2MQTT Integration",required:n,children:[(0,i.jsxs)("p",{children:["If you plan to integrate the ",t," with Zigbee2MQTT, you must have this integration set up. Installation methods differ between different installation types. Check out the documentation for full details on the required hardware and how to set up Zigbee2MQTT on your system."]}),(0,i.jsx)("p",{children:o}),(0,i.jsx)("a",{href:"https://www.zigbee2mqtt.io/",children:"Zigbee2MQTT Docs"})]})},zha:function(e){let{required:n,refers:t,children:o}=e;return(0,i.jsxs)(m,{name:"ZHA Integration",required:n,children:[(0,i.jsxs)("p",{children:["If you plan to integrate the ",t," with ZHA, you must have this integration set up. The ZHA integration can be configured from the Home Assistant UI. Check the documentation for full details on the required hardware and how to set up ZHA on your system."]}),(0,i.jsx)("p",{children:o}),(0,i.jsx)("a",{href:"https://www.home-assistant.io/integrations/zha/",children:"ZHA Integration Docs"})]})},deconz:e=>{let{required:n,refers:t,children:o}=e;return(0,i.jsxs)(m,{name:"deCONZ Integration",required:n,children:[(0,i.jsxs)("p",{children:["If you plan to integrate the ",t," with deCONZ, you must have this integration set up. The deCONZ integration can be configured from the Home Assistant UI and requires an additional container to run deCONZ on. Head over to the documentation for full details on the required hardware and how to set up deCONZ on your system."]}),(0,i.jsx)("p",{children:o}),(0,i.jsx)("a",{href:"https://www.home-assistant.io/integrations/deconz/",children:"deCONZ Integration Docs"})]})},shelly:function(e){let{required:n,refers:t,children:o}=e;return(0,i.jsxs)(m,{name:"Shelly Integration",required:n,children:[(0,i.jsxs)("p",{children:["If you plan to integrate the ",t," with Shelly, you must have this integration set up. The Shelly integration can be configured from the Home Assistant UI. Check the documentation for full details on the required hardware and how to set up Shelly on your system."]}),(0,i.jsx)("p",{children:o}),(0,i.jsx)("a",{href:"https://www.home-assistant.io/integrations/shelly/",children:"Shelly Integration Docs"})]})},controller:e=>{let{required:n,children:t}=e;return(0,i.jsxs)(m,{name:"Controller Automation",required:n,children:[(0,i.jsxs)("p",{children:["To use this blueprint you need to first create an automation with a Controller blueprint. You can then create an automation with this Hook,"," ",(0,i.jsx)("b",{children:"making sure that you provide the same controller device used in the corresponding Controller blueprint"}),". This key step will link the two automations and ensure the Hook will respond to events fired by the Controller."]}),(0,i.jsx)("p",{children:t}),(0,i.jsx)("a",{href:"#supported-controllers",children:"List of Supported Controllers"})," -"," ",(0,i.jsx)("a",{href:"https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers",children:"Controllers Docs"})]})}},f=e=>{let{id:n,required:t,name:o,refers:r,children:s}=e;const l=n?v[n]:m;return(0,i.jsx)(l,{name:o,required:t,refers:r,children:s})};var x=t(6807);const w={myHomeAssistantImage:{width:"100%",maxWidth:212}};const y=function(e){let{category:n,id:t}=e;const o=`/blueprints/${n}/${t}?version=latest`;return(0,i.jsxs)("div",{className:"card item shadow--md",children:[(0,i.jsx)("div",{className:"card__header margin-bottom--md",children:(0,i.jsx)("h3",{children:"Import this blueprint"})}),(0,i.jsx)("div",{className:"card__body",children:(0,i.jsx)("div",{className:"row row--no-gutters",children:(0,i.jsxs)("div",{className:"col col--12",children:[(0,i.jsx)("h5",{children:"My Home Assistant"}),(0,i.jsxs)("p",{children:[(0,i.jsx)(x.A,{to:o,target:"_blank",rel:"noreferrer",children:(0,i.jsx)("img",{src:"https://my.home-assistant.io/badges/blueprint_import.svg",alt:"Open your Home Assistant instance and show the blueprint import dialog with a specific blueprint pre-filled.",style:w.myHomeAssistantImage})}),(0,i.jsx)("br",{})]})]})})})]})};var j=t(8811);const k=e=>{let{id:n,title:t,description:r,category:s}=e;const[l,a]=(0,o.useState)(!1),d={width:"100%",minHeight:"200px",boxShadow:l?"0 4px 8px rgba(0, 0, 0, 0.3)":"0 2px 4px rgba(0, 0, 0, 0.2)",padding:"16px",color:"var(--ifm-font-color-base, #000)",cursor:"pointer",transition:"box-shadow 0.3s ease"},c={display:"flex",justifyContent:"flex-end",marginTop:"8px",transition:"transform 0.3s ease-out",transform:l?"translateX(6px)":"translateX(0)"};return(0,i.jsx)(x.A,{to:`/docs/blueprints/${s}/${n}`,style:{textDecoration:"none"},children:(0,i.jsxs)("div",{className:"card",style:d,onMouseEnter:()=>a(!0),onMouseLeave:()=>a(!1),children:[(0,i.jsx)("div",{className:"card__header",children:(0,i.jsx)("h3",{children:t})}),(0,i.jsx)("div",{className:"card__body",children:(0,i.jsx)("p",{children:r})}),(0,i.jsx)("div",{className:"card__footer",style:c,children:(0,i.jsx)(j.A,{size:20})})]})})},A=e=>{let{category:n}=e;const[t,r]=(0,o.useState)([]),[s,l]=(0,o.useState)(null);if((0,o.useEffect)((()=>{try{const e=c.keys(),t=`./${n}/`,o=e.filter((e=>e.startsWith(t)&&!e.includes("/example.mdx")&&!e.endsWith(`/${n}.mdx`))).map((e=>{const n=e.replace(t,"").replace(".mdx",""),o=c(e),{title:i,description:r}=o.frontMatter;return{id:n,title:i||n,description:r||""}}));o.sort(((e,n)=>e.title.localeCompare(n.title))),r(o),l(null)}catch(e){console.error("Error loading blueprints:",e),r([]),l("Failed to load blueprints. Please check the console for more details.")}}),[n]),s)return(0,i.jsxs)("div",{className:"admonition admonition-danger alert alert--danger",children:[(0,i.jsx)("div",{className:"admonition-heading",children:(0,i.jsx)("h5",{children:"Error loading blueprints"})}),(0,i.jsx)("div",{className:"admonition-content",children:(0,i.jsx)("p",{children:s})})]});if(0===t.length)return(0,i.jsx)("div",{children:"No blueprints found in this category."});return(0,i.jsx)("div",{style:{display:"flex",flexDirection:"column",gap:"16px",margin:"20px 0"},children:t.map((e=>(0,i.jsx)(k,{id:e.id,title:e.title,description:e.description,category:n},e.id)))})},q=e=>{let{id:n,model:t,manufacturer:r,integrations:s,image:l,model_name:a}=e;const[d,c]=(0,o.useState)(!1),u=Array.isArray(r)?r.join(", "):r,p={width:"100%",minHeight:"120px",boxShadow:d?"0 4px 8px rgba(0, 0, 0, 0.3)":"0 2px 4px rgba(0, 0, 0, 0.2)",padding:"16px",color:"var(--ifm-font-color-base, #000)",cursor:"pointer",display:"flex",alignItems:"flex-start",position:"relative",gap:"16px",transition:"box-shadow 0.3s ease"},h={display:"flex",flexDirection:"column",justifyContent:"flex-start",flex:1,overflow:"wrap",paddingRight:"24px"},_={position:"absolute",right:"16px",top:"50%",transform:"translateY(-50%) "+(d?"translateX(6px)":"translateX(0)"),transition:"transform 0.3s ease-out"};return(0,i.jsx)(x.A,{to:`/docs/blueprints/controllers/${n}`,style:{textDecoration:"none"},children:(0,i.jsxs)("div",{className:"card",style:p,onMouseEnter:()=>c(!0),onMouseLeave:()=>c(!1),children:[(0,i.jsx)("div",{style:h,children:(0,i.jsx)("h3",{style:{margin:"0"},children:a})}),(0,i.jsx)("img",{src:l,alt:a,style:{width:"150px",height:"auto",borderRadius:"8px",flexShrink:0}}),(0,i.jsxs)("div",{style:h,children:[(0,i.jsxs)("p",{style:{margin:"0"},children:[(0,i.jsx)("strong",{children:"Model:"})," ",t]}),(0,i.jsxs)("p",{style:{margin:"0"},children:[(0,i.jsx)("strong",{children:"Manufacturer:"})," ",u]}),(0,i.jsxs)("p",{style:{margin:"0"},children:[(0,i.jsx)("strong",{children:"Integrations:"})," ",s.join(", ")]})]}),(0,i.jsx)("div",{className:"card__footer",style:_,children:(0,i.jsx)(j.A,{size:20})})]})})};var T=t(4711);const M=()=>{const[e,n]=(0,o.useState)([]),[t,r]=(0,o.useState)([]),[s,l]=(0,o.useState)(null),[a,d]=(0,o.useState)([]),[u,p]=(0,o.useState)(0),[h,_]=(0,o.useState)(""),[g,b]=(0,o.useState)("All Manufacturers");if((0,o.useEffect)((()=>{try{const e=c.keys(),t="./controllers/",o=e.filter((e=>e.startsWith(t)&&!e.includes("/example.mdx")&&!e.endsWith("/controllers.mdx"))).map((e=>{const n=e.replace(t,"").replace(".mdx",""),o=c(e),{title:i,description:r,model:s,manufacturer:l,integrations:a,model_name:d}=o.frontMatter;return{id:n,title:i||n,description:r||"",model:Array.isArray(s)?s.join(", "):s||"",manufacturer:l||"",integrations:a||[],model_name:Array.isArray(d)?d.join(", "):d||""}}));o.sort(((e,n)=>e.title.localeCompare(n.title)));const i=new Set;o.forEach((e=>{Array.isArray(e.manufacturer)?e.manufacturer.forEach((e=>{e&&"string"==typeof e&&""!==e.trim()&&i.add(e.trim())})):e.manufacturer&&"string"==typeof e.manufacturer&&i.add(e.manufacturer.trim())})),n(o),r(o),p(o.length),d(Array.from(i)),l(null)}catch(e){console.error("Error loading controllers:",e),n([]),l("Failed to load controllers. Please check the console for more details.")}}),[]),(0,o.useEffect)((()=>{let n=e;if("All Manufacturers"!==g&&(n=n.filter((e=>Array.isArray(e.manufacturer)?e.manufacturer.some((e=>"string"==typeof e&&e.toLowerCase().includes(g.toLowerCase()))):"string"==typeof e.manufacturer&&e.manufacturer.toLowerCase().includes(g.toLowerCase())))),h){const e=h.toLowerCase();n=n.filter((n=>{const t="string"==typeof n.model_name&&n.model_name.toLowerCase().includes(e),o="string"==typeof n.model&&n.model.toLowerCase().includes(e);let i=!1;Array.isArray(n.manufacturer)?i=n.manufacturer.some((n=>"string"==typeof n&&n.toLowerCase().includes(e))):"string"==typeof n.manufacturer&&(i=n.manufacturer.toLowerCase().includes(e));const r=Array.isArray(n.integrations)&&n.integrations.some((n=>"string"==typeof n&&n.toLowerCase().includes(e)));return t||o||i||r}))}r(n)}),[h,g,e]),s)return(0,i.jsxs)("div",{className:"admonition admonition-danger alert alert--danger",children:[(0,i.jsx)("div",{className:"admonition-heading",children:(0,i.jsx)("h5",{children:"Error loading controllers"})}),(0,i.jsx)("div",{className:"admonition-content",children:(0,i.jsx)("p",{children:s})})]});if(0===e.length)return(0,i.jsx)("div",{children:"No controllers found in this category."});return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("div",{style:{marginBottom:"20px",padding:"12px 16px",backgroundColor:"var(--ifm-color-emphasis-100)",borderRadius:"8px",display:"flex",justifyContent:"space-between",flexWrap:"wrap"},children:(0,i.jsx)("div",{children:t.length===e.length?(0,i.jsxs)(i.Fragment,{children:["Currently ",u," devices from"," ",a.length," different vendors are supported."]}):(0,i.jsxs)(i.Fragment,{children:["Showing ",t.length," of ",u," ","devices."]})})}),(0,i.jsxs)("div",{style:{display:"flex",gap:"16px",marginBottom:"20px",flexWrap:"wrap"},children:[(0,i.jsxs)("div",{style:{position:"relative",flex:"2",minWidth:"200px"},children:[(0,i.jsx)(T.A,{style:{position:"absolute",left:"12px",top:"50%",transform:"translateY(-50%)",color:"var(--ifm-color-emphasis-500)"},size:16}),(0,i.jsx)("input",{type:"text",placeholder:"Search controllers...",style:{width:"100%",padding:"8px 8px 8px 36px",borderRadius:"4px",border:"1px solid var(--ifm-color-emphasis-300)",fontSize:"16px"},value:h,onChange:e=>_(e.target.value)})]}),(0,i.jsxs)("select",{style:{flex:"1",minWidth:"150px",padding:"8px",borderRadius:"4px",border:"1px solid var(--ifm-color-emphasis-300)",fontSize:"16px"},value:g,onChange:e=>b(e.target.value),children:[(0,i.jsx)("option",{children:"All Manufacturers"}),a.sort().map((e=>(0,i.jsx)("option",{value:e,children:e},e)))]})]}),(0,i.jsx)("div",{style:{display:"flex",flexDirection:"column",gap:"16px",margin:"20px 0"},children:t.map((e=>{const n=`/awesome-ha-blueprints/img/controllers/${e.id}.png`;return(0,i.jsx)(q,{id:e.id,model:e.model,model_name:e.model_name,manufacturer:e.manufacturer,integrations:e.integrations,image:n},e.id)}))})]})}},2885:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.02.13\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg13lm/xiaomi_wxcjkg13lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG13LM.html#aqara-wxcjkg13lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (triple band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (triple band) (WXCJKG13LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 6-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 6-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_3_short:\n      name: (Optional) Button 3 short press\n      description: Action to run on short button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_long:\n      name: (Optional) Button 3 long press\n      description: Action to run on long button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_release:\n      name: (Optional) Button 3 release\n      description: Action to run on button 3 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_3_double:\n      name: (Optional) Button 3 double press\n      description: Action to run on double button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_triple:\n      name: (Optional) Button 3 triple press\n      description: Action to run on triple button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_4_short:\n      name: (Optional) Button 4 short press\n      description: Action to run on short button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_long:\n      name: (Optional) Button 4 long press\n      description: Action to run on long button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_release:\n      name: (Optional) Button 4 release\n      description: Action to run on button 4 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_4_double:\n      name: (Optional) Button 4 double press\n      description: Action to run on double button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_triple:\n      name: (Optional) Button 4 triple press\n      description: Action to run on triple button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_5_short:\n      name: (Optional) Button 5 short press\n      description: Action to run on short button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_long:\n      name: (Optional) Button 5 long press\n      description: Action to run on long button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_release:\n      name: (Optional) Button 5 release\n      description: Action to run on button 5 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_5_double:\n      name: (Optional) Button 5 double press\n      description: Action to run on double button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_5_triple:\n      name: (Optional) Button 5 triple press\n      description: Action to run on triple button 5 press.\n      default: []\n      selector:\n        action:\n    action_button_6_short:\n      name: (Optional) Button 6 short press\n      description: Action to run on short button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_long:\n      name: (Optional) Button 6 long press\n      description: Action to run on long button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_release:\n      name: (Optional) Button 6 release\n      description: Action to run on button 6 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_6_double:\n      name: (Optional) Button 6 double press\n      description: Action to run on double button 6 press.\n      default: []\n      selector:\n        action:\n    action_button_6_triple:\n      name: (Optional) Button 6 triple press\n      description: Action to run on triple button 6 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_3_long_loop:\n      name: (Optional) Button 3 long press - loop until release\n      description: Loop the button 3 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_3_long_max_loop_repeats:\n      name: (Optional) Button 3 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_4_long_loop:\n      name: (Optional) Button 4 long press - loop until release\n      description: Loop the button 4 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_4_long_max_loop_repeats:\n      name: (Optional) Button 4 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_5_long_loop:\n      name: (Optional) Button 5 long press - loop until release\n      description: Loop the button 5 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_5_long_max_loop_repeats:\n      name: (Optional) Button 5 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_6_long_loop:\n      name: (Optional) Button 6 long press - loop until release\n      description: Loop the button 6 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_6_long_max_loop_repeats:\n      name: (Optional) Button 6 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  button_3_long_loop: !input button_3_long_loop\n  button_3_long_max_loop_repeats: !input button_3_long_max_loop_repeats\n  button_4_long_loop: !input button_4_long_loop\n  button_4_long_max_loop_repeats: !input button_4_long_max_loop_repeats\n  button_5_long_loop: !input button_5_long_loop\n  button_5_long_max_loop_repeats: !input button_5_long_max_loop_repeats\n  button_6_long_loop: !input button_6_long_loop\n  button_6_long_max_loop_repeats: !input button_6_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n      button_3_short: ['3002']\n      button_3_long: ['3001']\n      button_3_release: ['3003']\n      button_3_double: ['3004']\n      button_3_triple: ['3005']\n      button_4_short: ['4002']\n      button_4_long: ['4001']\n      button_4_release: ['4003']\n      button_4_double: ['4004']\n      button_4_triple: ['4005']\n      button_5_short: ['5002']\n      button_5_long: ['5001']\n      button_5_release: ['5003']\n      button_5_double: ['5004']\n      button_5_triple: ['5005']\n      button_6_short: ['6002']\n      button_6_long: ['6001']\n      button_6_release: ['6003']\n      button_6_double: ['6004']\n      button_6_triple: ['6005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n      button_3_short: [3_single]\n      button_3_long: [3_long press]\n      button_3_release: [3_release]\n      button_3_double: [3_double]\n      button_3_triple: [3_triple]\n      button_4_short: [4_single]\n      button_4_long: [4_long press]\n      button_4_release: [4_release]\n      button_4_double: [4_double]\n      button_4_triple: [4_triple]\n      button_5_short: [5_single]\n      button_5_long: [5_long press]\n      button_5_release: [5_release]\n      button_5_double: [5_double]\n      button_5_triple: [5_triple]\n      button_6_short: [6_single]\n      button_6_long: [6_long press]\n      button_6_release: [6_release]\n      button_6_double: [6_double]\n      button_6_triple: [6_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG13LM.html#aqara-wxcjkg13lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n      button_3_short: [button_3_single]\n      button_3_long: [button_3_hold]\n      button_3_release: [button_3_release]\n      button_3_double: [button_3_double]\n      button_3_triple: [button_3_triple]\n      button_4_short: [button_4_single]\n      button_4_long: [button_4_hold]\n      button_4_release: [button_4_release]\n      button_4_double: [button_4_double]\n      button_4_triple: [button_4_triple]\n      button_5_short: [button_5_single]\n      button_5_long: [button_5_hold]\n      button_5_release: [button_5_release]\n      button_5_double: [button_5_double]\n      button_5_triple: [button_5_triple]\n      button_6_short: [button_6_single]\n      button_6_long: [button_6_hold]\n      button_6_release: [button_6_release]\n      button_6_double: [button_6_double]\n      button_6_triple: [button_6_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  button_3_short: '{{ actions_mapping[integration_id][\"button_3_short\"] }}'\n  button_3_long: '{{ actions_mapping[integration_id][\"button_3_long\"] }}'\n  button_3_release: '{{ actions_mapping[integration_id][\"button_3_release\"] }}'\n  button_3_double: '{{ actions_mapping[integration_id][\"button_3_double\"] }}'\n  button_3_triple: '{{ actions_mapping[integration_id][\"button_3_triple\"] }}'\n  button_4_short: '{{ actions_mapping[integration_id][\"button_4_short\"] }}'\n  button_4_long: '{{ actions_mapping[integration_id][\"button_4_long\"] }}'\n  button_4_release: '{{ actions_mapping[integration_id][\"button_4_release\"] }}'\n  button_4_double: '{{ actions_mapping[integration_id][\"button_4_double\"] }}'\n  button_4_triple: '{{ actions_mapping[integration_id][\"button_4_triple\"] }}'\n  button_5_short: '{{ actions_mapping[integration_id][\"button_5_short\"] }}'\n  button_5_long: '{{ actions_mapping[integration_id][\"button_5_long\"] }}'\n  button_5_release: '{{ actions_mapping[integration_id][\"button_5_release\"] }}'\n  button_5_double: '{{ actions_mapping[integration_id][\"button_5_double\"] }}'\n  button_5_triple: '{{ actions_mapping[integration_id][\"button_5_triple\"] }}'\n  button_6_short: '{{ actions_mapping[integration_id][\"button_6_short\"] }}'\n  button_6_long: '{{ actions_mapping[integration_id][\"button_6_long\"] }}'\n  button_6_release: '{{ actions_mapping[integration_id][\"button_6_release\"] }}'\n  button_6_double: '{{ actions_mapping[integration_id][\"button_6_double\"] }}'\n  button_6_triple: '{{ actions_mapping[integration_id][\"button_6_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  # button_1\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  # button_2\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  # button_3\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_triple\n  # button_4\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_triple\n  # button_5\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_5_triple\n  # button_6\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_double\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_6_triple\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n      - conditions: '{{ trigger_action | string in button_3_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_short\n      - conditions: '{{ trigger_action | string in button_3_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_3_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_3_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_3_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_3_long\n      - conditions: '{{ trigger_action | string in button_3_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_release\n      - conditions: '{{ trigger_action | string in button_3_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_double\n      - conditions: '{{ trigger_action | string in button_3_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_triple\n      - conditions: '{{ trigger_action | string in button_4_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_short\n      - conditions: '{{ trigger_action | string in button_4_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_4_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_4_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_4_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_4_long\n      - conditions: '{{ trigger_action | string in button_4_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_release\n      - conditions: '{{ trigger_action | string in button_4_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_double\n      - conditions: '{{ trigger_action | string in button_4_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_triple\n      - conditions: '{{ trigger_action | string in button_5_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_short\n      - conditions: '{{ trigger_action | string in button_5_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_5_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_5_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_5_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_5_long\n      - conditions: '{{ trigger_action | string in button_5_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_release\n      - conditions: '{{ trigger_action | string in button_5_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_double\n      - conditions: '{{ trigger_action | string in button_5_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_5_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_5_triple\n      - conditions: '{{ trigger_action | string in button_6_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_short\n      - conditions: '{{ trigger_action | string in button_6_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_6_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_6_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_6_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_6_long\n      - conditions: '{{ trigger_action | string in button_6_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_release\n      - conditions: '{{ trigger_action | string in button_6_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_double\n      - conditions: '{{ trigger_action | string in button_6_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_6_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_6_triple\n"},4115:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 324131092621 Hue Dimmer switch\n  description: |\n    # Controller - Philips 324131092621 Hue Dimmer switch\n\n    Controller automation for executing any kind of action triggered by the provided Philips 324131092621 Hue Dimmer switch. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_324131092621/philips_324131092621.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/324131092621.html#philips-324131092621\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue dimmer switch (324131092621)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_on_short:\n      name: (Optional) On button short press\n      description: Action to run on short on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_long:\n      name: (Optional) On button long press\n      description: Action to run on long on button press.\n      default: []\n      selector:\n        action:\n    action_button_on_release:\n      name: (Optional) On button release\n      description: Action to run on on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_on_double:\n      name: (Optional) (Virtual) On button double press\n      description: Action to run on double on button press.\n      default: []\n      selector:\n        action:\n    action_button_off_short:\n      name: (Optional) Off button short press\n      description: Action to run on short off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_long:\n      name: (Optional) Off button long press\n      description: Action to run on long off button press.\n      default: []\n      selector:\n        action:\n    action_button_off_release:\n      name: (Optional) Off button release\n      description: Action to run on off button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_off_double:\n      name: (Optional) (Virtual) Off button double press\n      description: Action to run on double off button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_on_long_loop:\n      name: (Optional) On button long press - loop until release\n      description: Loop the on button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_on_long_max_loop_repeats:\n      name: (Optional) On button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_off_long_loop:\n      name: (Optional) Off button long press - loop until release\n      description: Loop the off button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_off_long_max_loop_repeats:\n      name: (Optional) Off button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_on_double_press:\n      name: (Optional) Expose on button double press event\n      description: Choose whether or not to expose the virtual double press event for the on button. Turn this on if you are providing an action for the on button double press event.\n      default: false\n      selector:\n        boolean:\n    button_off_double_press:\n      name: (Optional) Expose off button double press event\n      description: Choose whether or not to expose the virtual double press event for the off button. Turn this on if you are providing an action for the off button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_on_long_loop: !input button_on_long_loop\n  button_on_long_max_loop_repeats: !input button_on_long_max_loop_repeats\n  button_on_double_press: !input button_on_double_press\n  button_off_long_loop: !input button_off_long_loop\n  button_off_long_max_loop_repeats: !input button_off_long_max_loop_repeats\n  button_off_double_press: !input button_off_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_on_short: ['1000']\n      button_on_long: ['1001']\n      button_on_release: ['1003']\n      button_off_short: ['4000']\n      button_off_long: ['4001']\n      button_off_release: ['4003']\n      button_up_short: ['2000']\n      button_up_long: ['2001']\n      button_up_release: ['2003']\n      button_down_short: ['3000']\n      button_down_long: ['3001']\n      button_down_release: ['3003']\n    zha:\n      button_on_short: [on_short_release]\n      button_on_long: [on_hold]\n      button_on_release: [on_long_release]\n      button_off_short: [off_short_release]\n      button_off_long: [off_hold]\n      button_off_release: [off_long_release]\n      button_up_short: [up_short_release]\n      button_up_long: [up_hold]\n      button_up_release: [up_long_release]\n      button_down_short: [down_short_release]\n      button_down_long: [down_hold]\n      button_down_release: [down_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/324131092621.html#philips-324131092621\n      button_on_short: [on_press]\n      button_on_long: [on_hold]\n      button_on_release: [on_hold_release]\n      button_off_short: [off_press]\n      button_off_long: [off_hold]\n      button_off_release: [off_hold_release]\n      button_up_short: [up_press]\n      button_up_long: [up_hold]\n      button_up_release: [up_hold_release]\n      button_down_short: [down_press]\n      button_down_long: [down_hold]\n      button_down_release: [down_hold_release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_on_short: '{{ actions_mapping[integration_id][\"button_on_short\"] }}'\n  button_on_long: '{{ actions_mapping[integration_id][\"button_on_long\"] }}'\n  button_on_release: '{{ actions_mapping[integration_id][\"button_on_release\"] }}'\n  button_off_short: '{{ actions_mapping[integration_id][\"button_off_short\"] }}'\n  button_off_long: '{{ actions_mapping[integration_id][\"button_off_long\"] }}'\n  button_off_release: '{{ actions_mapping[integration_id][\"button_off_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: on_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: off_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: up_hold_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: down_hold_release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_on_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_on_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_on_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_on_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_on_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_on_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_on_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_on_short\n      - conditions: '{{ trigger_action | string in button_on_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_on_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_on_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_on_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_on_long\n      - conditions: '{{ trigger_action | string in button_on_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_on_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_on_release\n      - conditions: '{{ trigger_action | string in button_off_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_off_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_off_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_off_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_off_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_off_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_off_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_off_short\n      - conditions: '{{ trigger_action | string in button_off_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_off_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_off_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_off_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_off_long\n      - conditions: '{{ trigger_action | string in button_off_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_off_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_off_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions: '{{ trigger_action | string in button_up_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions: '{{ trigger_action | string in button_down_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},4154:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e1524_e1810","title":"Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e1524_e1810.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e1524_e1810","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1524_e1810","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e1524_e1810.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E1524/E1810","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote",description:"Controller automation for executing any kind of action triggered by the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E1524/E1810",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Center button long press",id:"center-button-long-press",level:3},{value:"Issues with the E1810 model firing bad events",id:"issues-with-the-e1810-model-firing-bad-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e1524_e1810",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1524_e1810#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e1524_e1810"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Color down"}),"\n",(0,i.jsx)(n.li,{children:"Left button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Right button long press -> Color up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Toggle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Previous track"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Center button long press -> Stop"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The helper is used to determine button release events when the controller is integrated with ZHA, because of the actions mapping for the controller with these integrations. Natively, the controller doesn't allow to distinguish between different button release events, so the blueprint must store the previous clicked button."}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"center-button-long-press",children:"Center button long press"}),"\n",(0,i.jsx)(n.p,{children:"Please note that the long press on the center button behaves differently from the long press for other buttons, due to how the controller implements this feature: when long pressing the center button, the controller first fires the short press event, then after a couple of seconds it sends the long press event as well. This behaviour is due to the controller design and it's not relative to any integration or the blueprint itself."}),"\n",(0,i.jsx)(n.h3,{id:"issues-with-the-e1810-model-firing-bad-events",children:"Issues with the E1810 model firing bad events"}),"\n",(0,i.jsx)(n.p,{children:"It has been reported that the newer IKEA E1810 controller, which looks identical to the E1524, might fire wrong events in certain situations when interacting with it. This is due to an issue with the controller design and is not relative to the blueprint itself."}),"\n",(0,i.jsx)(n.p,{children:"If you notice your controller is not behaving as expected please remove the battery, wait about 2 minutes, insert it back and try again."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-05"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-07"}),": fix an issue which prevented to create automations for ZHA or deCONZ."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-08"}),": update example, fixed an issue which executed actions twice when the remote was connected via Zigbee2MQTT."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-18"}),": added example for fully controlling a RGB light (thanks @kks36!)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-21"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"add support for virtual double press events"}),"\n",(0,i.jsx)(n.li,{children:"block automation runs for empty and repeated messages"}),"\n",(0,i.jsxs)(n.li,{children:["reduce ",(0,i.jsx)(n.code,{children:"input_text helper"})," writes"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-03"}),": move the blueprint in the Controllers-Hooks Ecosystem. See announcement ",(0,i.jsx)(n.a,{href:"https://community.home-assistant.io/t/awesome-ha-blueprints-a-curated-list-of-blueprints-easily-create-controller-based-automations-remotes-switches-for-controlling-lights-media-players-and-more/256687/7",children:"here"}),". ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),": ","\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": standardize input names across all the Controller blueprints.\nIf you plan to update this blueprint, please update the inputs in your automations as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_device"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zigbee2mqtt_remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_entity"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"action_*"})," inputs -> ",(0,i.jsx)(n.code,{children:"action_button_*"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helper_last_loop_event_input"})," -> ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": add support for the Cover Hook"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-30"}),": Fix event mappings for ZHA and deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": Fix double press events not being detected with deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with four new blueprint inputs"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n",(0,i.jsx)(n.li,{children:"Fix for Zigbee2MQTT reporting null state changes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-04"}),": Fix deCONZ button release events not being properly recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-03"}),": Fixed double press events not triggered due to changes in Home Assistant 2023.5.x. (",(0,i.jsx)(n.a,{href:"https://github.com/ZtormTheCat",children:"@ZtormTheCat"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-04-01"}),": Fix double-click detection logic. (",(0,i.jsx)(n.a,{href:"https://github.com/danleongjy",children:"@danleongjy"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},4277:e=>{"use strict";e.exports='# Blueprint metadata\nblueprint:\n  name: Controller - SONOFF SNZB-01 Wireless Switch\n  description: |\n    # Controller - SONOFF SNZB-01 Wireless Switch\n\n    Controller automation for executing any kind of action triggered by the provided SONOFF SNZB-01 Wireless Switch.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/sonoff_snzb01/sonoff_snzb01.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: \'\'\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/SNZB-01.html#ewelink-snzb-01\n            - integration: mqtt\n              manufacturer: eWeLink\n              model: Wireless button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: eWeLink\n              model: Wireless button (SNZB-01)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: eWeLink\n              model: WB01\n            - integration: deconz\n              manufacturer: eWeLink\n              model: WB01\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: \'\'\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: \'{{ integration | lower }}\'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: [\'1002\']\n      button_long: [\'1001\']\n      button_double: [\'1004\']\n    zha:\n      button_short: [toggle]\n      button_long: [\'off\']\n      button_double: [\'on\']\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/SNZB-01.html#ewelink-snzb-01\n      button_short: [single]\n      button_long: [long]\n      button_double: [double]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: \'{{ actions_mapping[integration_id]["button_short"] }}\'\n  button_long: \'{{ actions_mapping[integration_id]["button_long"] }}\'\n  button_double: \'{{ actions_mapping[integration_id]["button_double"] }}\'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: long\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: double\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in ["","None"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it\'s the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == "zigbee2mqtt" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == "deconz" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == "zha" -%}\n        {{ trigger.event.data.command }}{{"_" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join("_") }}\n        {%- endif -%}\n      trigger_delta: \'{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match("^\\{((\\"a\\": \\".*\\"|\\"t\\": \\d+\\.\\d+)(, )?){2}\\}$")) else as_timestamp("1970-01-01 00:00:00"))) * 1000 }}\'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: \'{{ {"a":trigger_action,"t":as_timestamp(now())} | to_json }}\'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: \'{{ trigger_action | string in button_short }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_short\n      - conditions: \'{{ trigger_action | string in button_long }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_long\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_long\n      - conditions: \'{{ trigger_action | string in button_double }}\'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: \'{{ controller_id }}\'\n              action: button_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_double\n'},4388:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e1744","title":"Controller - IKEA E1744 SYMFONISK Rotary Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1744 SYMFONISK Rotary Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e1744.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e1744","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1744","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e1744.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E1744 SYMFONISK Rotary Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1744 SYMFONISK Rotary Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E1744","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E1744 SYMFONISK Rotary Remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E1744 SYMFONISK Rotary Remote",description:"Controller automation for executing any kind of action triggered by the provided IKEA E1744 SYMFONISK Rotary Remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E1744",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E1744 SYMFONISK Rotary Remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e1744",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E1744 SYMFONISK Rotary Remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to optionally loop the rotate actions while the remote is rotating either left or right. Once the remote stops rotating, the loop stops as well. This is useful when rotating the controller should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1744#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.Kg,{id:"zigbee2mqtt",children:[(0,i.jsx)(s.Kg,{id:"zha"}),(0,i.jsx)(s.Kg,{id:"deconz"}),(0,i.jsxs)(n.p,{children:["When configuring the remote with Zigbee2MQTT make sure to disable the legacy integration for it, as reported ",(0,i.jsx)(n.a,{href:"https://www.zigbee2mqtt.io/devices/E1744.html#legacy-integration",children:"here"}),". This blueprint won't work with controllers with a legacy integration due to their instability and fundamental problems."]})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e1744"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Brightness down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Brightness up (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Remote short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Remote double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Remote triple press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Volume down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Volume up (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Remote short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Remote double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Remote triple press -> Previous track"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The helper is used to determine stop rotation events when the controller is integrated with Zigbee2MQTT, ZHA, because of the actions mapping for the controller with these integrations. Natively, the controller doesn't allow to distinguish between different rotation events, so the blueprint must store the previous rotation."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-07"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Standardize input names across all the Controller blueprints.\nIf you plan to update this blueprint, please update the inputs in your automations as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_device"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zigbee2mqtt_remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_entity"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"action_click"})," -> ",(0,i.jsx)(n.code,{children:"action_click_short"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": align action mapping format for deCONZ across all the Controller blueprints"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-14"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with two new blueprint inputs"}),"\n",(0,i.jsx)(n.li,{children:"Use any RAW stop event (left/right) to identify the stop event corresponding to the current remote rotation"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),": Fix for Zigbee2MQTT reporting null state changes"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-04"}),": Fix deCONZ rotation stop events not being properly recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-05"}),": Update ZHA event data to what ZHA provides in HA 2024.03.01 (",(0,i.jsx)(n.a,{href:"https://github.com/ogajduse",children:"@ogajduse"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},4509:e=>{"use strict";e.exports="# Blueprint Metadata\nblueprint:\n  name: Controller - IKEA E2201 RODRET Dimmer\n  description: |\n    # Controller - IKEA E2201 RODRET Dimmer\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2201 RODRET Dimmer.\n    Allows to optionally loop an action on a button long press.\n    Allows for Virtual Double Presses. Needs to be enabled in blueprint.\n    Supports Zigbee2MQTT, ZHA, deCONZ.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with lights, covers, media players, and potentially more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20c\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2201).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2201/ikea_e2201.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  # Device Selector\n  input:\n    controller_device:\n      name: (Zigbee2MQTT, ZHA, deCONZ Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with Zigbee2MQTT, ZHA, deCONZ.\n      default: ''\n      selector:\n        # source: https://zigbee.blakadder.com/Ikea_E2201.html\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2201.html#ikea-e2201\n            - integration: mqtt\n              manufacturer: IKEA\n              model: RODRET wireless dimmer/power switch\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: RODRET wireless dimmer/power switch (E2201)\n            # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/twobtnremote.py#L206\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: RODRET Dimmer\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L236\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: RODRET Dimmer\n          multiple: false\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    long_press_options_section:\n      name: Long Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_up_long_max_loop_repeats:\n          name: (Optional) Up button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_down_long_max_loop_repeats:\n          name: (Optional) Down button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        helper_long_press_delay:\n          name: (Optional) Helper - Long Press delay\n          description: Max delay between the pushing and releasing of a button long press event. Increase this value if you notice that the long press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n    # inputs for enabling double press events\n    double_press_options_section:\n      name: Double Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_up_double_press_exposed:\n          name: (Optional) Expose up button double press event\n          description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n          default: false\n          selector:\n            boolean:\n        button_down_double_press_exposed:\n          name: (Optional) Expose down button double press event\n          description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n          default: false\n          selector:\n            boolean:\n        # helper used to properly adjust the remote button double press events\n        helper_double_press_delay:\n          name: (Optional) Helper - Double Press delay\n          description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n#\n# Automation schema\nvariables:\n  # Controller ID\n  controller_id: !input controller_device\n  # integration id used to select items in the action mapping\n  # integration type is set from trigger.id\n  integration_id: '{{ trigger.id.split(\"-\")[0] }}'\n  # convert input tags to variables, to be used in templates\n  # Button Inputs For Loop\n  helper_long_press_delay: !input helper_long_press_delay\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  # Button Inputs for Virtual Double Press\n  helper_double_press_delay: !input helper_double_press_delay\n  button_up_double_press_exposed: !input button_up_double_press_exposed\n  button_down_double_press_exposed: !input button_down_double_press_exposed\n  # mapping between actions and integrations\n  actions_mapping:\n    z2m:\n      # source: https://www.zigbee2mqtt.io/devices/E2201.html#ikea-e2201\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n    zha:\n      # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/twobtnremote.py#L206\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off]\n      button_up_release: [stop_with_on_off]\n      button_down_short: ['off']\n      button_down_long: [move]\n      button_down_release: [stop]\n    dcz:\n      # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L236\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n  # pre-choose actions for buttons based on configured integration\n  # mainly used to pass to hooks through ahb_controller_event\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n#\n# Mode Block\nmode: single\nmax_exceeded: silent\n#\n# Triggers Block\ntriggers:\n  # triggers for zigbee2mqtt\n  - trigger: device\n    id: z2m-button-up-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    id: z2m-button-up-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    id: z2m-button-up-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    id: z2m-button-down-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    id: z2m-button-down-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  - trigger: device\n    id: z2m-button-down-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for ZHA\n  - trigger: event\n    id: zha-button-up-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: 'on'\n      endpoint_id: 1\n      cluster_id: 6\n  - trigger: event\n    id: zha-button-up-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move_with_on_off\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0, 83]\n  - trigger: event\n    id: zha-button-up-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: stop_with_on_off\n      endpoint_id: 1\n      cluster_id: 8\n  - trigger: event\n    id: zha-button-down-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: 'off'\n      endpoint_id: 1\n      cluster_id: 6\n  - trigger: event\n    id: zha-button-down-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1, 83, 0, 0]\n  - trigger: event\n    id: zha-button-down-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: stop\n      endpoint_id: 1\n      cluster_id: 8\n  # triggers for deCONZ\n  - trigger: event\n    id: dcz-button-up-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1002'\n  - trigger: event\n    id: dcz-button-up-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1001'\n  - trigger: event\n    id: dcz-button-up-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1003'\n  - trigger: event\n    id: dcz-button-down-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2002'\n  - trigger: event\n    id: dcz-button-down-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2001'\n  - trigger: event\n    id: dcz-button-down-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2003'\n#\n# Conditions Block\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"z2m\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- elif integration_id == \"dcz\" -%}\n        {{ trigger.event.data.event }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\n#\n# Actions Block\nactions:\n  #\n  # choose the sequence to run based on the received button event\n  - choose:\n      #\n      # Actions for Up Button Single Press / Double Press Virtual\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-short\n              - zha-button-up-short\n              - dcz-button-up-short\n        sequence:\n          # Check If Double Press is Exposed\n          - if:\n              - condition: template\n                value_template: '{{ button_up_double_press_exposed }}'\n            then:\n              # Handle Double Press\n              - choose:\n                  # Wait for z2m/zha/dcz triggers for second Button Press to treat as a Double Press\n                  - conditions: []\n                    sequence:\n                      - wait_for_trigger:\n                          # z2m trigger\n                          - trigger: device\n                            domain: mqtt\n                            device_id: !input controller_device\n                            type: action\n                            subtype: 'on'\n                          # zha trigger\n                          - trigger: event\n                            event_type: zha_event\n                            event_data:\n                              device_id: !input controller_device\n                              command: 'on'\n                              cluster_id: 6\n                              endpoint_id: 1\n                          # dcz trigger\n                          - trigger: event\n                            event_type: deconz_event\n                            event_data:\n                              device_id: !input controller_device\n                              event: '1002'\n                        timeout:\n                          milliseconds: '{{ helper_double_press_delay }}'\n                        continue_on_timeout: true\n                      # If a second button short press is triggered wait.trigger.idx will be defined\n                      - if:\n                          - condition: template\n                            value_template: '{{ wait.trigger.idx is defined }}'\n                        # Second short press trigger was received send Hook and Custom Actions as a Double Press\n                        then:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                        # Second short press trigger was not received send Hook and Custom Actions as a Single Press\n                        else:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_short\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_short\n            # Double Press is Not Exposed So send Hook and Custom Actions as a Single Press\n            else:\n              # fire the ahb hook event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      #\n      # Actions for Down Button Single Press / Double Press Virtual\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-short\n              - zha-button-down-short\n              - dcz-button-down-short\n        sequence:\n          # Check If Double Press is Exposed\n          - if:\n              - condition: template\n                value_template: '{{ button_down_double_press_exposed }}'\n            # Handle Double Press\n            then:\n              - choose:\n                  # Wait for z2m/zha/dcz triggers for second Button Press to treat as a Double Press\n                  - conditions: []\n                    sequence:\n                      - wait_for_trigger:\n                          # z2m trigger\n                          - trigger: device\n                            domain: mqtt\n                            device_id: !input controller_device\n                            type: action\n                            subtype: 'off'\n                          # zha trigger\n                          - trigger: event\n                            event_type: zha_event\n                            event_data:\n                              device_id: !input controller_device\n                              command: 'off'\n                              cluster_id: 6\n                              endpoint_id: 1\n                          # dcz trigger\n                          - trigger: event\n                            event_type: deconz_event\n                            event_data:\n                              device_id: !input controller_device\n                              event: '2002'\n                        timeout:\n                          milliseconds: '{{ helper_double_press_delay }}'\n                        continue_on_timeout: true\n                      # If a second button short press is triggered wait.trigger.idx will be defined\n                      - if:\n                          - condition: template\n                            value_template: '{{ wait.trigger.idx is defined }}'\n                        # Second short press trigger was received send Hook and Custom Actions as a Double Press\n                        then:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                        # Second short press trigger was not received send Hook and Custom Actions as a Single Press\n                        else:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_short\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_short\n            # Double Press is Not Exposed So send Hook and Custom Actions as a Single Press\n            else:\n              # fire the ahb hook event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      #\n      # Actions for Button Up Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-long\n              - zha-button-up-long\n              - dcz-button-up-long\n        sequence:\n          # Repeat the Long Press Actions for the set number of loops\n          - repeat:\n              count: !input button_up_long_max_loop_repeats\n              sequence:\n                - parallel:\n                    - event: ahb_controller_event\n                      event_data:\n                        controller: '{{ controller_id }}'\n                        action: button_up_long\n                    - sequence:\n                        - choose:\n                            - conditions: []\n                              sequence: !input action_button_up_long\n                    - sequence:\n                        - choose:\n                            # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                            - conditions: []\n                              sequence:\n                                - wait_for_trigger:\n                                    - trigger: device\n                                      domain: mqtt\n                                      device_id: !input controller_device\n                                      type: action\n                                      subtype: brightness_stop\n                                    - trigger: event\n                                      event_type: zha_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        command: stop_with_on_off\n                                        cluster_id: 8\n                                        endpoint_id: 1\n                                    - trigger: event\n                                      event_type: deconz_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        event: '1003'\n                                  timeout:\n                                    milliseconds: !input helper_long_press_delay\n                                  continue_on_timeout: true\n                                # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                - if:\n                                    - condition: template\n                                      value_template: '{{ wait.trigger.idx is defined }}'\n                                  then:\n                                    # fire the event\n                                    - event: ahb_controller_event\n                                      event_data:\n                                        controller: '{{ controller_id }}'\n                                        action: button_up_release\n                                    # run the custom action\n                                    - choose:\n                                        - conditions: []\n                                          sequence: !input action_button_up_release\n                                    # Stop the repeat loop\n                                    - stop: button_up_released\n      #\n      # Actions for Button Down Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-long\n              - zha-button-down-long\n              - dcz-button-down-long\n        sequence:\n          # Repeat the Long Press Actions for the set number of loops\n          - repeat:\n              count: !input button_down_long_max_loop_repeats\n              sequence:\n                - parallel:\n                    - event: ahb_controller_event\n                      event_data:\n                        controller: '{{ controller_id }}'\n                        action: button_down_long\n                    - sequence:\n                        - choose:\n                            - conditions: []\n                              sequence: !input action_button_down_long\n                    - sequence:\n                        - choose:\n                            # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                            - conditions: []\n                              sequence:\n                                - wait_for_trigger:\n                                    - trigger: device\n                                      domain: mqtt\n                                      device_id: !input controller_device\n                                      type: action\n                                      subtype: brightness_stop\n                                    - trigger: event\n                                      event_type: zha_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        command: stop\n                                        cluster_id: 8\n                                        endpoint_id: 1\n                                    - trigger: event\n                                      event_type: deconz_event\n                                      event_data:\n                                        device_id: !input controller_device\n                                        event: '2003'\n                                  timeout:\n                                    milliseconds: !input helper_long_press_delay\n                                  continue_on_timeout: true\n                                # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                - if:\n                                    - condition: template\n                                      value_template: '{{ wait.trigger.idx is defined }}'\n                                  then:\n                                    # fire the event\n                                    - event: ahb_controller_event\n                                      event_data:\n                                        controller: '{{ controller_id }}'\n                                        action: button_down_release\n                                    # run the custom action\n                                    - choose:\n                                        - conditions: []\n                                          sequence: !input action_button_down_release\n                                    # Stop the repeat loop\n                                    - stop: button_down_released\n      #\n      # Actions for Up Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-up-release\n              - zha-button-up-release\n              - dcz-button-up-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      #\n      # Actions for Down Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-down-release\n              - zha-button-down-release\n              - dcz-button-down-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},4565:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch\n  description: |\n    # Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch\n\n    Controller automation for executing any kind of action triggered by the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxkg11lm/xiaomi_wxkg11lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXKG01LM.html#xiaomi-wxkg01lm\n            # Xiaomi WXKG01LM\n            - integration: mqtt\n              manufacturer: Xiaomi\n              model: Mi wireless switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Xiaomi\n              model: Mi wireless switch (WXKG01LM)\n            # source: https://www.zigbee2mqtt.io/devices/WXKG11LM.html#aqara-wxkg11lm\n            # Aqara WXKG11LM\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Wireless mini switch\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Wireless mini switch (WXKG11LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Mi round smart wireless switch\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Mi round smart wireless switch\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1002']\n      button_long: ['1001']\n      button_release: ['1003']\n      button_double: ['1004']\n    zha:\n      button_short: [single_value]\n      button_long: [hold_value]\n      button_release: [release_value]\n      button_double: [double_value]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXKG01LM.html#xiaomi-wxkg01lm\n      # source: https://www.zigbee2mqtt.io/devices/WXKG11LM.html#aqara-wxkg11lm\n      button_short: [single]\n      button_long: [hold]\n      button_release: [release]\n      button_double: [double]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  button_double: '{{ actions_mapping[integration_id][\"button_double\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: single\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: double\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n      - conditions: '{{ trigger_action | string in button_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_double\n"},4605:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e2001_e2002","title":"Controller - IKEA E2001/E2002 STYRBAR Remote control","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2001/E2002 STYRBAR Remote control. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e2001_e2002.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e2001_e2002","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e2001_e2002.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E2001/E2002 STYRBAR Remote control","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2001/E2002 STYRBAR Remote control. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E2001/E2002","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E2001/E2002 STYRBAR Remote control"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E2001/E2002 STYRBAR Remote control",description:"Controller automation for executing any kind of action triggered by the provided IKEA E2001/E2002 STYRBAR Remote control. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E2001/E2002",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E2001/E2002 STYRBAR Remote control"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Issues with Zigbee2MQTT and the device firing duplicate events",id:"issues-with-zigbee2mqtt-and-the-device-firing-duplicate-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e2001_e2002",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E2001/E2002 STYRBAR Remote control. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2001_e2002#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e2001_e2002"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Color down"}),"\n",(0,i.jsx)(n.li,{children:"Left button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Right button long press -> Color up (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn on"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn off"]}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Color down"}),"\n",(0,i.jsx)(n.li,{children:"Left button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Right button long press -> Color up (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Stop"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Previous track"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Next track"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The helper is used to determine button release events when the controller is integrated with Zigbee2MQTT, ZHA, because of the actions mapping for the controller with these integrations. Natively, the controller doesn't allow to distinguish between different button release events, so the blueprint must store the previous clicked button."}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"issues-with-zigbee2mqtt-and-the-device-firing-duplicate-events",children:"Issues with Zigbee2MQTT and the device firing duplicate events"}),"\n",(0,i.jsx)(n.p,{children:"It has been reported that IKEA E2001/E2002 controllers integrated with Zigbee2MQTT might fire duplicate events from time to time, during interaction. This issue is not relative to the blueprint itself."}),"\n",(0,i.jsx)(n.p,{children:"If you notice your controller is not behaving as expected please reset the device and repeat the pairing process with Zigbee2MQTT, then try again."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-07"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-02"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["(ZHA) Fixed a bug preventing long pressing actions to be triggered. (",(0,i.jsx)(n.a,{href:"https://github.com/Ivarvdb",children:"@Ivarvdb"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:['(Zigbee2MQTT) handle "unknown" state. (',(0,i.jsx)(n.a,{href:"https://github.com/beardhatcode",children:"@beardhatcode"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-03"}),": Remove spaces to match new helper format in Home Assistant 2023.5.x. (",(0,i.jsx)(n.a,{href:"https://github.com/LordSushiPhoenix",children:"@LordSushiPhoenix"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-04-01"}),": Fix double-click detection logic. (",(0,i.jsx)(n.a,{href:"https://github.com/danleongjy",children:"@danleongjy"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},4617:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: On-Off schedule with state persistence\n  description: |\n    # On-Off schedule with state persistence\n\n    A simple on-off schedule, with the addition of state persistence across disruptive events, making sure the target device is always in the expected state.\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/on_off_schedule_state_persistence).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n    \u2139\ufe0f Version 2021.10.26\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/on_off_schedule_state_persistence/on_off_schedule_state_persistence.yaml\n  domain: automation\n  input:\n    automation_target:\n      name: (Required) Automation target\n      description: The target which the automation will turn on and off based on the provided schedule.\n      selector:\n        target:\n    on_time:\n      name: (Required) On Time\n      description: Time when the target should be placed in the on state.\n      selector:\n        time:\n    off_time:\n      name: (Required) Off Time\n      description: Time when the target should be placed in the off state.\n      selector:\n        time:\n    custom_trigger_event:\n      name: (Optional) Custom Trigger Event\n      description: A custom event which can trigger the state check (eg. a powercut event reported by external integrations).\n      default: ''\n      selector:\n        text:\n    trigger_at_homeassistant_startup:\n      name: (Optional) Trigger at Home Assistant startup\n      description: Trigger the target state check and enforcement at Home Assistant startup.\n      default: false\n      selector:\n        boolean:\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  off_time: !input off_time\n  on_time: !input on_time\n  trigger_at_homeassistant_startup: !input trigger_at_homeassistant_startup\n  # time format used by strptime\n  time_fmt: '%H:%M:%S'\n  # first define whether on_time or off_time is the first event to occur during a specific day\n  first_event: '{{ on_time if strptime(on_time,time_fmt).time() < strptime(off_time,time_fmt).time() else off_time }}'\n  second_event: '{{ on_time if strptime(on_time,time_fmt).time() >= strptime(off_time,time_fmt).time() else off_time }}'\nmode: single\nmax_exceeded: silent\n\n# trigger at specified time, home assistant startup or when the custom event is fired\ntrigger:\n  - platform: time\n    at:\n      - !input on_time\n      - !input off_time\n  - platform: homeassistant\n    event: start\n  - platform: event\n    event_type: !input custom_trigger_event\n# if triggered by the homeassistant platform check if the automation should be run, as specified by the user\n# if triggered by something else, just continue\ncondition:\n  - condition: template\n    value_template: '{{ trigger.platform!=\"homeassistant\" or trigger_at_homeassistant_startup }}'\naction:\n  - choose:\n      # if current time is in the range first_event...second_event the target must be in the first_event state\n      - conditions:\n          - condition: template\n            value_template: '{{ now().time() >= strptime(first_event,time_fmt).time() and now().time() < strptime(second_event,time_fmt).time() }}'\n        sequence:\n          - service: 'homeassistant.{{ \"turn_on\" if first_event == on_time else \"turn_off\"}}'\n            target: !input automation_target\n    # else current time is in the range second_event...23:59:59 or 00:00:00...first_event\n    # the target must be in the second_event state\n    default:\n      - service: 'homeassistant.{{ \"turn_on\" if second_event == on_time else \"turn_off\"}}'\n        target: !input automation_target\n"},4639:e=>{"use strict";e.exports="# Blueprint Metadata\nblueprint:\n  name: Controller - IKEA E2213 SOMRIG shortcut button\n  description: |\n    # Controller - IKEA E2213 SOMRIG shortcut button\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2213 SOMRIG shortcut button.\n    Allows to optionally loop an action on a button long press.\n    The blueprint handles double button press events natively as it is supported by the controller device itself.\n    Supports Zigbee2MQTT, ZHA, deCONZ.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with lights, covers, media players, and potentially more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2213#available-hooks) for additional details.\n\n    A small note, avoid using both custom actions and Hooks in the same blueprint, otherwise strange things may occur.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.26\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2213/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2213).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2213/ikea_e2213.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  # Device Selector\n  input:\n    controller_device:\n      name: (Required) (Zigbee2MQTT, ZHA, deCONZ) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with Zigbee2MQTT, ZHA, deCONZ.\n      default: ''\n      selector:\n        # source: [Blackadder Source NOT AVAILABLE]\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2213.html\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SOMRIG shortcut button\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: SOMRIG shortcut button (E2213)\n            # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/somrigsmartbtn.py#L149\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: SOMRIG Shortcut Button\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L343\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: SOMRIG Shortcut Button\n          multiple: false\n    # inputs for custom actions\n    action_button_dots1_short:\n      name: (Optional) Dots1 button short press\n      description: Action to run on short dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_long:\n      name: (Optional) Dots1 button long press\n      description: Action to run on long dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_release:\n      name: (Optional) Dots1 button release\n      description: Action to run on dots1 button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_dots1_double:\n      name: (Optional) Dots1 button double press\n      description: Action to run on double dots1 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_short:\n      name: (Optional) Dots2 button short press\n      description: Action to run on short dots2 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_long:\n      name: (Optional) Dots2 button long press\n      description: Action to run on long dots2 button press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_release:\n      name: (Optional) Dots2 button release\n      description: Action to run on dots2 button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_dots2_double:\n      name: (Optional) Dots2 button double press\n      description: Action to run on double dots2 button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    long_press_options_section:\n      name: Long Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        button_dots1_long_loop:\n          name: (Optional) Dots1 button long press - loop until release\n          description: Loop the dots1 button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_dots1_long_max_loop_repeats:\n          name: (Optional) Dots1 button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        button_dots2_long_loop:\n          name: (Optional) Dots2 button long press - loop until release\n          description: Loop the dots2 button action until the button is released.\n          default: false\n          selector:\n            boolean:\n        button_dots2_long_max_loop_repeats:\n          name: (Optional) Dots2 button long press - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 20\n          selector:\n            number:\n              min: 1.0\n              max: 1000.0\n              mode: slider\n              step: 1.0\n        helper_long_press_delay:\n          name: (Optional) Helper - Long Press delay\n          description: Max delay between the pushing and releasing of a button long press event. Increase this value if you notice that the long press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n#\n# Automation schema\nvariables:\n  # Controller ID\n  controller_id: !input controller_device\n  # integration id used to select items in the action mapping\n  # integration type is set from trigger.id\n  integration_id: '{{ trigger.id.split(\"-\")[0] }}'\n  # convert input tags to variables, to be used in templates\n  button_dots1_long_loop: !input button_dots1_long_loop\n  button_dots1_long_max_loop_repeats: !input button_dots1_long_max_loop_repeats\n  button_dots2_long_loop: !input button_dots2_long_loop\n  button_dots2_long_max_loop_repeats: !input button_dots2_long_max_loop_repeats\n  helper_long_press_delay: !input helper_long_press_delay\n  # mapping between actions and integrations\n  actions_mapping:\n    z2m:\n      # source: https://www.zigbee2mqtt.io/devices/E2213.html\n      button_dots1_short: [1_short_release]\n      button_dots1_long: [1_long_press]\n      button_dots1_release: [1_long_release]\n      button_dots1_double: [1_double_press]\n      button_dots2_short: [2_short_release]\n      button_dots2_long: [2_long_press]\n      button_dots2_release: [2_long_release]\n      button_dots2_double: [2_double_press]\n    zha:\n      # source: https://github.com/zigpy/zha-device-handlers/blob/dev/zhaquirks/ikea/somrigsmartbtn.py#L149\n      button_dots1_short: [short_release_1]\n      button_dots1_long: [long_press_1]\n      button_dots1_release: [long_release_1]\n      button_dots1_double: [multi_press_complete_1]\n      button_dots2_short: [short_release_2]\n      button_dots2_long: [long_press_2]\n      button_dots2_release: [long_release_2]\n      button_dots2_double: [multi_press_complete_2]\n    dcz:\n      # source: https://github.com/dresden-elektronik/deconz-rest-plugin/blob/8ae69a976bca13f22e8002a13ebe798d1e26c086/button_maps.json#L343\n      button_dots1_short: ['1003']\n      button_dots1_long: ['1002']\n      button_dots1_release: ['1004']\n      button_dots1_double: ['1006']\n      button_dots2_short: ['2003']\n      button_dots2_long: ['2002']\n      button_dots2_release: ['2004']\n      button_dots2_double: ['2006']\n  # pre-choose actions for buttons based on configured integration\n  # mainly used to pass to hooks through ahb_controller_event\n  button_dots1_short: '{{ actions_mapping[integration_id][\"button_dots1_short\"] }}'\n  button_dots1_long: '{{ actions_mapping[integration_id][\"button_dots1_long\"] }}'\n  button_dots1_release: '{{ actions_mapping[integration_id][\"button_dots1_release\"] }}'\n  button_dots1_double: '{{ actions_mapping[integration_id][\"button_dots1_double\"] }}'\n  button_dots2_short: '{{ actions_mapping[integration_id][\"button_dots2_short\"] }}'\n  button_dots2_long: '{{ actions_mapping[integration_id][\"button_dots2_long\"] }}'\n  button_dots2_release: '{{ actions_mapping[integration_id][\"button_dots2_release\"] }}'\n  button_dots2_double: '{{ actions_mapping[integration_id][\"button_dots2_double\"] }}'\n#\n# Mode Block\nmode: single\nmax_exceeded: silent\n#\n# Triggers Block\ntriggers:\n  # triggers for zigbee2mqtt\n  - trigger: device\n    id: z2m-button-dots1-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 1_short_release\n  - trigger: device\n    id: z2m-button-dots1-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 1_long_press\n  - trigger: device\n    id: z2m-button-dots1-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 1_long_release\n  - trigger: device\n    id: z2m-button-dots1-double\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 1_double_press\n  - trigger: device\n    id: z2m-button-dots2-short\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 2_short_release\n  - trigger: device\n    id: z2m-button-dots2-long\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 2_long_press\n  - trigger: device\n    id: z2m-button-dots2-release\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 2_long_release\n  - trigger: device\n    id: z2m-button-dots2-double\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 2_double_press\n  # triggers for ZHA\n  - trigger: event\n    id: zha-button-dots1-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: short_release\n      endpoint_id: 1\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots1-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_press\n      endpoint_id: 1\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots1-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_release\n      endpoint_id: 1\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots1-double\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: multi_press_complete\n      endpoint_id: 1\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots2-short\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: short_release\n      endpoint_id: 2\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots2-long\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_press\n      endpoint_id: 2\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots2-release\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: long_release\n      endpoint_id: 2\n      cluster_id: 64640\n  - trigger: event\n    id: zha-button-dots2-double\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: multi_press_complete\n      endpoint_id: 2\n      cluster_id: 64640\n  # triggers for deCONZ\n  - trigger: event\n    id: dcz-button-dots1-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1003'\n  - trigger: event\n    id: dcz-button-dots1-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1002'\n  - trigger: event\n    id: dcz-button-dots1-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1004'\n  - trigger: event\n    id: dcz-button-dots1-double\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '1006'\n  - trigger: event\n    id: dcz-button-dots2-short\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2003'\n  - trigger: event\n    id: dcz-button-dots2-long\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2002'\n  - trigger: event\n    id: dcz-button-dots2-release\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2004'\n  - trigger: event\n    id: dcz-button-dots2-double\n    event_type:\n      - deconz_event\n    event_data:\n      device_id: !input controller_device\n      event: '2006'\n#\n# Conditions Block\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"z2m\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- elif integration_id == \"dcz\" -%}\n        {{ trigger.event.data.event }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\n#\n# Actions Block\nactions:\n  #\n  # choose the sequence to run based on the received button event\n  - choose:\n      #\n      # Actions for Dots1 Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots1-short\n              - zha-button-dots1-short\n              - dcz-button-dots1-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_short\n      #\n      # Actions for Dots1 Button Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots1-long\n              - zha-button-dots1-long\n              - dcz-button-dots1-long\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_long\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_long\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ button_dots1_long_loop }}'\n                sequence:\n                  # Repeat the Long Press Actions for the set number of loops\n                  - repeat:\n                      count: !input button_dots1_long_max_loop_repeats\n                      sequence:\n                        - parallel:\n                            - sequence: !input action_button_dots1_long\n                            - sequence:\n                                - choose:\n                                    - conditions: []\n                                      sequence:\n                                        # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                                        - wait_for_trigger:\n                                            # z2m triggers\n                                            - trigger: device\n                                              domain: mqtt\n                                              device_id: !input controller_device\n                                              type: action\n                                              subtype: 1_long_release\n                                            # zha triggers\n                                            - trigger: event\n                                              event_type: zha_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                command: long_release\n                                                endpoint_id: 1\n                                                cluster_id: 64640\n                                            # dcz triggers\n                                            - trigger: event\n                                              event_type: deconz_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                event: '1004'\n                                          timeout:\n                                            milliseconds: !input helper_long_press_delay\n                                          continue_on_timeout: true\n                                        # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                        - if:\n                                            - condition: template\n                                              value_template: '{{ wait.trigger.idx is defined }}'\n                                          then:\n                                            # fire the event\n                                            - event: ahb_controller_event\n                                              event_data:\n                                                controller: '{{ controller_id }}'\n                                                action: button_dots1_release\n                                            # run the custom action\n                                            - choose:\n                                                - conditions: []\n                                                  sequence: !input action_button_dots1_release\n                                            # Stop the repeat loop\n                                            - stop: button_dots1_released\n      #\n      # Actions for Dots1 Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots1-release\n              - zha-button-dots1-release\n              - dcz-button-dots1-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_release\n      #\n      # Actions for Dots1 Button double press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots1-double\n              - zha-button-dots1-double\n              - dcz-button-dots1-double\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots1_double\n      #\n      # Actions for Dots2 Button single press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots2-short\n              - zha-button-dots2-short\n              - dcz-button-dots2-short\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_short\n      #\n      # Actions for Dots2 Button Long Press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots2-long\n              - zha-button-dots2-long\n              - dcz-button-dots2-long\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_long\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_long\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ button_dots2_long_loop }}'\n                sequence:\n                  # Repeat the Long Press Actions for the set number of loops\n                  - repeat:\n                      count: !input button_dots2_long_max_loop_repeats\n                      sequence:\n                        - parallel:\n                            - sequence: !input action_button_dots2_long\n                            - sequence:\n                                - choose:\n                                    - conditions: []\n                                      sequence:\n                                        # Wait for z2m/zha/dcz triggers for Button Long Press Release to stop looping\n                                        - wait_for_trigger:\n                                            # z2m triggers\n                                            - trigger: device\n                                              domain: mqtt\n                                              device_id: !input controller_device\n                                              type: action\n                                              subtype: 2_long_release\n                                            # zha triggers\n                                            - trigger: event\n                                              event_type: zha_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                command: long_release\n                                                endpoint_id: 2\n                                                cluster_id: 64640\n                                            # dcz triggers\n                                            - trigger: event\n                                              event_type: deconz_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                event: '2004'\n                                          timeout:\n                                            milliseconds: !input helper_long_press_delay\n                                          continue_on_timeout: true\n                                        # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                        - if:\n                                            - condition: template\n                                              value_template: '{{ wait.trigger.idx is defined }}'\n                                          then:\n                                            # fire the event\n                                            - event: ahb_controller_event\n                                              event_data:\n                                                controller: '{{ controller_id }}'\n                                                action: button_dots2_release\n                                            # run the custom action\n                                            - choose:\n                                                - conditions: []\n                                                  sequence: !input action_button_dots2_release\n                                            # Stop the repeat loop\n                                            - stop: button_dots2_released\n      #\n      # Actions for Dots2 Button long press released\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots2-release\n              - zha-button-dots2-release\n              - dcz-button-dots2-release\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_release\n      #\n      # Actions for Dots2 Button double press\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-button-dots2-double\n              - zha-button-dots2-double\n              - dcz-button-dots2-double\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_dots2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_dots2_double\n"},4655:(e,n,t)=>{var o={"./automation/addon_update_notification/addon_update_notification.yaml":2761,"./automation/example/example.yaml":6957,"./automation/on_off_schedule_state_persistence/on_off_schedule_state_persistence.yaml":4617,"./automation/persistent_notification_to_mobile/persistent_notification_to_mobile.yaml":2625,"./automation/simple_safe_scheduler/simple_safe_scheduler.yaml":6993,"./controllers/ikea_e1524_e1810/ikea_e1524_e1810.yaml":2115,"./controllers/ikea_e1743/ikea_e1743.yaml":849,"./controllers/ikea_e1744/ikea_e1744.yaml":2219,"./controllers/ikea_e1766/ikea_e1766.yaml":5167,"./controllers/ikea_e1812/ikea_e1812.yaml":9159,"./controllers/ikea_e2001_e2002/ikea_e2001_e2002.yaml":5377,"./controllers/ikea_e2123/ikea_e2123.yaml":2703,"./controllers/ikea_e2201/ikea_e2201.yaml":4509,"./controllers/ikea_e2213/ikea_e2213.yaml":4639,"./controllers/ikea_ictc_g_1/ikea_ictc_g_1.yaml":2085,"./controllers/osram_ac025xx00nj/osram_ac025xx00nj.yaml":1209,"./controllers/philips_324131092621/philips_324131092621.yaml":4115,"./controllers/philips_8718699693985/philips_8718699693985.yaml":6237,"./controllers/philips_929002398602/philips_929002398602.yaml":719,"./controllers/sonoff_snzb01/sonoff_snzb01.yaml":4277,"./controllers/tuya_ERS-10TZBVK-AA/tuya_ERS-10TZBVK-AA.yaml":8861,"./controllers/xiaomi_wxcjkg11lm/xiaomi_wxcjkg11lm.yaml":2429,"./controllers/xiaomi_wxcjkg12lm/xiaomi_wxcjkg12lm.yaml":6161,"./controllers/xiaomi_wxcjkg13lm/xiaomi_wxcjkg13lm.yaml":2885,"./controllers/xiaomi_wxkg11lm/xiaomi_wxkg11lm.yaml":4565,"./hooks/cover/cover.yaml":1552,"./hooks/light/light.yaml":1212,"./hooks/media_player/media_player.yaml":9250};function i(e){var n=r(e);return t(n)}function r(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}i.keys=function(){return Object.keys(o)},i.resolve=r,e.exports=i,i.id=4655},5058:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/hooks/media_player","title":"Hook - Media Player","description":"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection.","source":"@site/docs/blueprints/hooks/media_player.mdx","sourceDirName":"blueprints/hooks","slug":"/blueprints/hooks/media_player","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks/media_player","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/hooks/media_player.mdx","tags":[],"version":"current","frontMatter":{"title":"Hook - Media Player","description":"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Hook - Media Player",description:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Supported Controllers",id:"supported-controllers",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"media_player",category:"hooks"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["An automation created with this blueprint must be linked to a ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers",children:"Controller"})," automation. Controllers are blueprints which allow to easily integrate a wide range of controllers and use them to run a set of actions when interacting with them. They expose an abstract interface used by Hooks to create controller-based automations."]}),(0,i.jsxs)(n.p,{children:["See the list of ",(0,i.jsx)(n.a,{href:"#supported-controllers",children:"Controllers supported by this Hook"})," for additional details."]})]}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"controller",required:!0}),"\n",(0,i.jsxs)(s.Kg,{name:"Media Player Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the entity which represents a media player in Home Assistant. It should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/media_player/",children:"Media Player Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"hooks",id:"media_player"}),"\n",(0,i.jsx)(n.h2,{id:"supported-controllers",children:"Supported Controllers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Aqara WXKG11LM Wireless Mini Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1524_e1810",children:"IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1743",children:"IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1744",children:"IKEA E1744 SYMFONISK Rotary Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1766",children:"IKEA E1766 TR\xc5DFRI Open/Close Remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1812",children:"IKEA E1812 TR\xc5DFRI Shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2001_e2002",children:"IKEA E2001/E2002 STYRBAR Remote control"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2123",children:"IKEA E2123 SYMFONISK sound remote, gen 2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2201",children:"IKEA E2201 RODRET Dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2213",children:"IKEA E2213 SOMRIG shortcut button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_ictc_g_1",children:"IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/osram_ac025xx00nj",children:"OSRAM AC025XX00NJ SMART+ Switch Mini"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_324131092621",children:"Philips 324131092621 Hue Dimmer switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_8718699693985",children:"Philips 8718699693985 Hue Smart Button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_929002398602",children:"Philips 929002398602 Hue Dimmer switch v2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/sonoff_snzb01",children:"SONOFF SNZB-01 Wireless Switch"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA",children:"Tuya ERS-10TZBVK-AA Smart knob"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg11lm",children:"Xiaomi WXCJKG11LM Aqara Opple 2 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg12lm",children:"Xiaomi WXCJKG12LM Aqara Opple 4 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg13lm",children:"Xiaomi WXCJKG13LM Aqara Opple 6 button remote"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm",children:"Xiaomi WXKG01LM Mi Wireless Switch"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsxs)(n.p,{children:["Not all media players support the customization of the number of steps for volume control, due to the fact that some of them do not expose their current volume level to Home Assistant. In these situations, the automation will fallback to the ",(0,i.jsx)(n.code,{children:"media_player.volume_up"})," and ",(0,i.jsx)(n.code,{children:"media_player.volume_down"})," services."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-04"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-07"}),": add support for IKEA E1744 SYMFONISK rotary remote"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-14"}),": add support for IKEA E1812 Shortcut button, fix E1743 naming"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),": update action mapping for IKEA E1744. If you're using this Hook with an IKEA E1744, please update also the corresponding Controller blueprint"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": add the ability to specify number of steps from min to max volume, both for short and long actions, when controlling the media player"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-27"}),": Add support for Philips Hue dimmer switch"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": remove unused variable, fix warnings for undefined variables in Home Assistant Core >=2021.4.0"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-16"}),": Add support for Osram SMART+ Switch Mini"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-03"}),": Add support for Philips Hue Smart Button"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Standardize blueprints structure and inputs naming across the whole collection."}),"\n",(0,i.jsx)(n.li,{children:"Improve blueprint documentation."}),"\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add support for alternate mappings. Additional mappings for currently supported controllers will be added from now on. Refer to the documentation of your controller for more details."]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": update controller names in the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, to match the full name of controllers, prevent ambiguities and enable support for alternate mappings. After updating this blueprint, please reconfigure your automations by selecting again the value for the ",(0,i.jsx)(n.code,{children:"Controller Model"})," input, matching the full name of the controller you're using with this hook."]}),"\n",(0,i.jsx)(n.li,{children:"Fix typo for IKEA E1524/E1810 center button long press action in mapping definition."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-29"}),": Add support for IKEA E1766 TR\xc5DFRI Open/Close Remote."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-07"}),": Add support for IKEA E2001/E2002 STYRBAR Remote control."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-21"}),": Add support for Philips 929002398602 Hue Dimmer switch v2."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": Add support for Xiaomi WXCJKG11LM, WXCJKG12LM, WXCJKG13LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-22"}),": Add support for Xiaomi WXKG11LM."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-30"}),": Add support for SONOFF SNZB-01."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-16"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Add support for Xiaomi WXKG01LM Mi Wireless Switch, rename Xiaomi WXKG11LM Aqara Wireless Switch Mini to Aqara WXKG11LM Wireless Mini Switch"}),"\n",(0,i.jsxs)(n.p,{children:["If you had configured the ",(0,i.jsx)(n.code,{children:"controller_model"})," input to ",(0,i.jsx)(n.code,{children:"Xiaomi WXKG11LM Aqara Wireless Switch Mini"}),", please change it to ",(0,i.jsx)(n.code,{children:"Aqara WXKG11LM Wireless Mini Switch"}),".\nThe change has been implemented to match the controller with the correct manufacturer name (Aqara)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Added support for IKEA E2201 RODRET Dimmer. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-26"}),": Added support for IKEA E2213 SOMRIG shortcut button. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-28"}),": Added support for IKEA E2123 SYMFONISK sound remote, gen 2. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-29"}),": Added support for Tuya ERS-10TZBVK-AA Smart knob. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5167:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote\n  description: |\n    # Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1766 TR\xc5DFRI Open/Close Remote.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.04.01\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1766/ikea_e1766.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1766.html#ikea-e1766\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI open/close remote\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI open/close remote (E1766)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI open/close remote\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI open/close remote\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for enabling double press events\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_up_double_press: !input button_up_double_press\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_up_short: ['1002']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_release: ['2003']\n    zha:\n      button_up_short: [up_open]\n      button_up_release: [stop]\n      button_down_short: [down_close]\n      button_down_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1766.html#ikea-e1766\n      button_up_short: [open]\n      button_up_release: [stop]\n      button_down_short: [close]\n      button_down_release: [stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: open\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: close\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_up\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_down\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},5339:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e2123","title":"Controller - IKEA E2123 SYMFONISK sound remote, gen 2","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2123 SYMFONISK sound remote, gen 2. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e2123.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e2123","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2123","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e2123.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E2123 SYMFONISK sound remote, gen 2","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2123 SYMFONISK sound remote, gen 2. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E2123","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E2123 SYMFONISK sound remote, gen 2"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E2123 SYMFONISK sound remote, gen 2",description:"Controller automation for executing any kind of action triggered by the provided IKEA E2123 SYMFONISK sound remote, gen 2. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E2123",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E2123 SYMFONISK sound remote, gen 2"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"(Default) Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"(Default) Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"(Default) Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Dots1 and Dots2 Long/Double press custom actions",id:"dots1-and-dots2-longdouble-press-custom-actions",level:3},{value:"Firmware compatability",id:"firmware-compatability",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e2123",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E2123 SYMFONISK sound remote, gen 2. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. The blueprint will automagically detect the integration type and take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint handles double button press events natively for the dots1/dots2 buttons as it is supported by the controller device itself.\nLong and Double press events can be enabled/disabled for each of the dots1/dots2 buttons to get extra speed in recognizing single press events."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with lights, media players, covers and maybe more in the future. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2123#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e2123"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Center button short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Color down"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button long press -> Color up (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Center button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Prev track"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Stop"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Right button short press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Left button short press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"dots1-and-dots2-longdouble-press-custom-actions",children:"Dots1 and Dots2 Long/Double press custom actions"}),"\n",(0,i.jsx)(n.p,{children:"The blueprint handles double button press events natively for the dots1/dots2 buttons as it is supported by the controller device itself.\nLong and Double press events can be enabled/disabled for each of the dots1/dots2 buttons to get extra speed in recognizing single press events."}),"\n",(0,i.jsx)(n.h3,{id:"firmware-compatability",children:"Firmware compatability"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint is only compatible with firmwares 1.0.32 (20221219) and 1.0.35 (20230308) of the IKEA E2123 SYMFONISK sound remote, gen 2."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-28"}),": Initial release. [Initial Release] (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),") ","\ud83c\udf89"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5377:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E2001/E2002 STYRBAR Remote control\n  description: |\n    # Controller - IKEA E2001/E2002 STYRBAR Remote control\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E2001/E2002 STYRBAR Remote control. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.04.01\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2001_e2002).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e2001_e2002/ikea_e2001_e2002.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E2001_E2002.html#ikea-e2001-e2002\n            - integration: mqtt\n              manufacturer: IKEA\n              model: STYRBAR remote control\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: STYRBAR remote control (E2001/E2002)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: Remote Control N2\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: Remote Control N2\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_left_short:\n      name: (Optional) Left button short press\n      description: Action to run on short left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_long:\n      name: (Optional) Left button long press\n      description: Action to run on long left button press.\n      default: []\n      selector:\n        action:\n    action_button_left_release:\n      name: (Optional) Left button release\n      description: Action to run on left button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_left_double:\n      name: (Optional) (Virtual) Left button double press\n      description: Action to run on double left button press.\n      default: []\n      selector:\n        action:\n    action_button_right_short:\n      name: (Optional) Right button short press\n      description: Action to run on short right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_long:\n      name: (Optional) Right button long press\n      description: Action to run on long right button press.\n      default: []\n      selector:\n        action:\n    action_button_right_release:\n      name: (Optional) Right button release\n      description: Action to run on right button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_right_double:\n      name: (Optional) (Virtual) Right button double press\n      description: Action to run on double right button press.\n      default: []\n      selector:\n        action:\n    action_button_up_short:\n      name: (Optional) Up button short press\n      description: Action to run on short up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_long:\n      name: (Optional) Up button long press\n      description: Action to run on long up button press.\n      default: []\n      selector:\n        action:\n    action_button_up_release:\n      name: (Optional) Up button release\n      description: Action to run on up button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_up_double:\n      name: (Optional) (Virtual) Up button double press\n      description: Action to run on double up button press.\n      default: []\n      selector:\n        action:\n    action_button_down_short:\n      name: (Optional) Down button short press\n      description: Action to run on short down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_long:\n      name: (Optional) Down button long press\n      description: Action to run on long down button press.\n      default: []\n      selector:\n        action:\n    action_button_down_release:\n      name: (Optional) Down button release\n      description: Action to run on down button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_down_double:\n      name: (Optional) (Virtual) Down button double press\n      description: Action to run on double down button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_left_long_loop:\n      name: (Optional) Left button long press - loop until release\n      description: Loop the left button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_left_long_max_loop_repeats:\n      name: (Optional) Left button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_right_long_loop:\n      name: (Optional) Right button long press - loop until release\n      description: Loop the right button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_right_long_max_loop_repeats:\n      name: (Optional) Right button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_up_long_loop:\n      name: (Optional) Up button long press - loop until release\n      description: Loop the up button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_up_long_max_loop_repeats:\n      name: (Optional) Up button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_down_long_loop:\n      name: (Optional) Down button long press - loop until release\n      description: Loop the down button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_down_long_max_loop_repeats:\n      name: (Optional) Down button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_left_double_press:\n      name: (Optional) Expose left button double press event\n      description: Choose whether or not to expose the virtual double press event for the left button. Turn this on if you are providing an action for the left button double press event.\n      default: false\n      selector:\n        boolean:\n    button_right_double_press:\n      name: (Optional) Expose right button double press event\n      description: Choose whether or not to expose the virtual double press event for the right button. Turn this on if you are providing an action for the right button double press event.\n      default: false\n      selector:\n        boolean:\n    button_up_double_press:\n      name: (Optional) Expose up button double press event\n      description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n      default: false\n      selector:\n        boolean:\n    button_down_double_press:\n      name: (Optional) Expose down button double press event\n      description: Choose whether or not to expose the virtual double press event for the down button. Turn this on if you are providing an action for the down button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_left_long_loop: !input button_left_long_loop\n  button_left_long_max_loop_repeats: !input button_left_long_max_loop_repeats\n  button_left_double_press: !input button_left_double_press\n  button_right_long_loop: !input button_right_long_loop\n  button_right_long_max_loop_repeats: !input button_right_long_max_loop_repeats\n  button_right_double_press: !input button_right_double_press\n  button_up_long_loop: !input button_up_long_loop\n  button_up_long_max_loop_repeats: !input button_up_long_max_loop_repeats\n  button_up_double_press: !input button_up_double_press\n  button_down_long_loop: !input button_down_long_loop\n  button_down_long_max_loop_repeats: !input button_down_long_max_loop_repeats\n  button_down_double_press: !input button_down_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_left_short: ['3002']\n      button_left_long: ['3001']\n      button_left_release: ['3003']\n      button_right_short: ['4002']\n      button_right_long: ['4001']\n      button_right_release: ['4003']\n      button_up_short: ['1002']\n      button_up_long: ['1001']\n      button_up_release: ['1003']\n      button_down_short: ['2002']\n      button_down_long: ['2001']\n      button_down_release: ['2003']\n    zha:\n      button_left_short: [press_257_13_0]\n      button_left_long: [hold_3329_0]\n      button_left_release: [release]\n      button_right_short: [press_256_13_0]\n      button_right_long: [hold_3328_0]\n      button_right_release: [release]\n      button_up_short: ['on']\n      button_up_long: [move_with_on_off_0_83, move_with_on_off_MoveMode.Up_83]\n      # Kept first parameter for potential backwards compatibility of previous firmware versions\n      button_up_release: [stop, stop_with_on_off]\n      button_down_short: ['off']\n      button_down_long: [move_1_83, move_MoveMode.Down_83_0_0]\n      # Kept first parameter for potential backwards compatibility of previous firmware versions\n      button_down_release: [stop, stop_with_on_off]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E2001_E2002.html#ikea-e2001-e2002\n      button_left_short: [arrow_left_click]\n      button_left_long: [arrow_left_hold]\n      button_left_release: [arrow_left_release]\n      button_right_short: [arrow_right_click]\n      button_right_long: [arrow_right_hold]\n      button_right_release: [arrow_right_release]\n      button_up_short: ['on']\n      button_up_long: [brightness_move_up]\n      button_up_release: [brightness_stop]\n      button_down_short: ['off']\n      button_down_long: [brightness_move_down]\n      button_down_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_left_short: '{{ actions_mapping[integration_id][\"button_left_short\"] }}'\n  button_left_long: '{{ actions_mapping[integration_id][\"button_left_long\"] }}'\n  button_left_release: '{{ actions_mapping[integration_id][\"button_left_release\"] }}'\n  button_right_short: '{{ actions_mapping[integration_id][\"button_right_short\"] }}'\n  button_right_long: '{{ actions_mapping[integration_id][\"button_right_long\"] }}'\n  button_right_release: '{{ actions_mapping[integration_id][\"button_right_release\"] }}'\n  button_up_short: '{{ actions_mapping[integration_id][\"button_up_short\"] }}'\n  button_up_long: '{{ actions_mapping[integration_id][\"button_up_long\"] }}'\n  button_up_release: '{{ actions_mapping[integration_id][\"button_up_release\"] }}'\n  button_down_short: '{{ actions_mapping[integration_id][\"button_down_short\"] }}'\n  button_down_long: '{{ actions_mapping[integration_id][\"button_down_long\"] }}'\n  button_down_release: '{{ actions_mapping[integration_id][\"button_down_release\"] }}'\n  # integrations which need to store the previous press event to determine which button was released\n  integrations_with_prev_event_storage: [zha, zigbee2mqtt]\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_left_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_click\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: arrow_right_release\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_down\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n      last_controller_event: '{{ (states(helper_last_controller_event) | from_json).a if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else \"\" }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_left_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_left_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_left\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_left_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_left_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_left_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_left_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_left_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_left_short\n      - conditions: '{{ trigger_action | string in button_left_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_left_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_left_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_left_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_left_long\n      - conditions:\n          # target all release events without considering the event suffix\n          - '{{ trigger_action.split(\"_\")[0] in button_left_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_left_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_left_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_left_release\n      - conditions: '{{ trigger_action | string in button_right_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_right_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_right\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_right_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_right_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_right_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_right_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_right_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_right_short\n      - conditions: '{{ trigger_action | string in button_right_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_right_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_right_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_right_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_right_long\n      - conditions:\n          # target all release events without considering the event suffix\n          - '{{  trigger_action.split(\"_\")[0]in button_right_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_right_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_right_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_right_release\n      - conditions: '{{ trigger_action | string in button_up_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_up_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_up\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_up_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_up_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_up_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_up_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_up_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_up_short\n      - conditions: '{{ trigger_action | string in button_up_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_up_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_up_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_up_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_up_long\n      - conditions:\n          - '{{ trigger_action | string in button_up_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_up_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_up_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_up_release\n      - conditions: '{{ trigger_action | string in button_down_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_down_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string == last_controller_event and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press_down\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_down_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_down_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_down_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_down_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_down_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_down_short\n      - conditions: '{{ trigger_action | string in button_down_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_down_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_down_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_down_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_down_long\n      - conditions:\n          - '{{ trigger_action | string in button_down_release }}'\n          # for integrations which need to store the last controller event, need to check the previous button event, stored in the provided input_text\n          - '{{ not integration_id in integrations_with_prev_event_storage or last_controller_event | string in button_down_long }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_down_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_down_release\n"},5630:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/xiaomi_wxcjkg11lm","title":"Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/xiaomi_wxcjkg11lm.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/xiaomi_wxcjkg11lm","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg11lm","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/xiaomi_wxcjkg11lm.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"WXCJKG11LM","manufacturer":"Xiaomi","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"Xiaomi WXCJKG11LM Aqara Opple 2 button remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Xiaomi WXCJKG11LM Aqara Opple 2 button remote",description:"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"WXCJKG11LM",manufacturer:"Xiaomi",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"Xiaomi WXCJKG11LM Aqara Opple 2 button remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"xiaomi_wxcjkg11lm",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Xiaomi WXCJKG11LM Aqara Opple 2 button remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg11lm#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"xiaomi_wxcjkg11lm"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5864:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/osram_ac025xx00nj","title":"Controller - OSRAM AC025XX00NJ SMART+ Switch Mini","description":"Controller automation for executing any kind of action triggered by the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/osram_ac025xx00nj.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/osram_ac025xx00nj","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/osram_ac025xx00nj","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/osram_ac025xx00nj.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - OSRAM AC025XX00NJ SMART+ Switch Mini","description":"Controller automation for executing any kind of action triggered by the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"AC025XX00NJ","manufacturer":"OSRAM","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"OSRAM AC025XX00NJ SMART+ Switch Mini"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - OSRAM AC025XX00NJ SMART+ Switch Mini",description:"Controller automation for executing any kind of action triggered by the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"AC025XX00NJ",manufacturer:"OSRAM",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"OSRAM AC025XX00NJ SMART+ Switch Mini"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"osram_ac025xx00nj",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided OSRAM AC025XX00NJ SMART+ Switch Mini. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/osram_ac025xx00nj#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"osram_ac025xx00nj"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color up"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color down"]}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Toggle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Previous track"]}),"\n",(0,i.jsx)(n.li,{children:"Center button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Center button long press -> Toggle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This blueprint supports any variant of the Osram SMART+ Switch Mini controller (AC025XX00NJ). Different model IDs (AC0251100NJ, AC0251400NJ, AC0251600NJ, AC0251700NJ) represent just a different device color."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-18"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),": Fix for Zigbee2MQTT reporting null state changes"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-05"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Updated Actions Mapping as per Z2M ",(0,i.jsx)(n.a,{href:"https://www.zigbee2mqtt.io/devices/AC0251100NJ_AC0251600NJ_AC0251700NJ.html#actions",children:"docs"})," for the device. (",(0,i.jsx)(n.a,{href:"https://github.com/alexdelprete",children:"@alexdelprete"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Fix regex for updated helper JSON serialization starting from Home Assistant 2023.5.0."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},6161:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n  description: |\n    # Controller - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n\n    Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG12LM Aqara Opple 4 button remote. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg12lm).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/xiaomi_wxcjkg12lm/xiaomi_wxcjkg12lm.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/WXCJKG12LM.html#aqara-wxcjkg12lm\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (double band)\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Aqara\n              model: Opple wireless switch (double band) (WXCJKG12LM)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed**  model: Aqara Opple 4-gang\n            - integration: deconz\n            # **TBConfirmed** manufacturer: Xiaomi\n            # **TBConfirmed** model: Aqara Opple 4-gang\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_1_short:\n      name: (Optional) Button 1 short press\n      description: Action to run on short button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_long:\n      name: (Optional) Button 1 long press\n      description: Action to run on long button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_release:\n      name: (Optional) Button 1 release\n      description: Action to run on button 1 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_1_double:\n      name: (Optional) Button 1 double press\n      description: Action to run on double button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_1_triple:\n      name: (Optional) Button 1 triple press\n      description: Action to run on triple button 1 press.\n      default: []\n      selector:\n        action:\n    action_button_2_short:\n      name: (Optional) Button 2 short press\n      description: Action to run on short button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_long:\n      name: (Optional) Button 2 long press\n      description: Action to run on long button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_release:\n      name: (Optional) Button 2 release\n      description: Action to run on button 2 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_2_double:\n      name: (Optional) Button 2 double press\n      description: Action to run on double button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_2_triple:\n      name: (Optional) Button 2 triple press\n      description: Action to run on triple button 2 press.\n      default: []\n      selector:\n        action:\n    action_button_3_short:\n      name: (Optional) Button 3 short press\n      description: Action to run on short button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_long:\n      name: (Optional) Button 3 long press\n      description: Action to run on long button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_release:\n      name: (Optional) Button 3 release\n      description: Action to run on button 3 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_3_double:\n      name: (Optional) Button 3 double press\n      description: Action to run on double button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_3_triple:\n      name: (Optional) Button 3 triple press\n      description: Action to run on triple button 3 press.\n      default: []\n      selector:\n        action:\n    action_button_4_short:\n      name: (Optional) Button 4 short press\n      description: Action to run on short button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_long:\n      name: (Optional) Button 4 long press\n      description: Action to run on long button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_release:\n      name: (Optional) Button 4 release\n      description: Action to run on button 4 release after long press.\n      default: []\n      selector:\n        action:\n    action_button_4_double:\n      name: (Optional) Button 4 double press\n      description: Action to run on double button 4 press.\n      default: []\n      selector:\n        action:\n    action_button_4_triple:\n      name: (Optional) Button 4 triple press\n      description: Action to run on triple button 4 press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_1_long_loop:\n      name: (Optional) Button 1 long press - loop until release\n      description: Loop the button 1 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_1_long_max_loop_repeats:\n      name: (Optional) Button 1 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_2_long_loop:\n      name: (Optional) Button 2 long press - loop until release\n      description: Loop the button 2 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_2_long_max_loop_repeats:\n      name: (Optional) Button 2 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_3_long_loop:\n      name: (Optional) Button 3 long press - loop until release\n      description: Loop the button 3 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_3_long_max_loop_repeats:\n      name: (Optional) Button 3 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    button_4_long_loop:\n      name: (Optional) Button 4 long press - loop until release\n      description: Loop the button 4 action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_4_long_max_loop_repeats:\n      name: (Optional) Button 4 long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # helpers used to properly recognize the remote button events\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_1_long_loop: !input button_1_long_loop\n  button_1_long_max_loop_repeats: !input button_1_long_max_loop_repeats\n  button_2_long_loop: !input button_2_long_loop\n  button_2_long_max_loop_repeats: !input button_2_long_max_loop_repeats\n  button_3_long_loop: !input button_3_long_loop\n  button_3_long_max_loop_repeats: !input button_3_long_max_loop_repeats\n  button_4_long_loop: !input button_4_long_loop\n  button_4_long_max_loop_repeats: !input button_4_long_max_loop_repeats\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_1_short: ['1002']\n      button_1_long: ['1001']\n      button_1_release: ['1003']\n      button_1_double: ['1004']\n      button_1_triple: ['1005']\n      button_2_short: ['2002']\n      button_2_long: ['2001']\n      button_2_release: ['2003']\n      button_2_double: ['2004']\n      button_2_triple: ['2005']\n      button_3_short: ['3002']\n      button_3_long: ['3001']\n      button_3_release: ['3003']\n      button_3_double: ['3004']\n      button_3_triple: ['3005']\n      button_4_short: ['4002']\n      button_4_long: ['4001']\n      button_4_release: ['4003']\n      button_4_double: ['4004']\n      button_4_triple: ['4005']\n    zha:\n      button_1_short: [1_single]\n      button_1_long: [1_long press]\n      button_1_release: [1_release]\n      button_1_double: [1_double]\n      button_1_triple: [1_triple]\n      button_2_short: [2_single]\n      button_2_long: [2_long press]\n      button_2_release: [2_release]\n      button_2_double: [2_double]\n      button_2_triple: [2_triple]\n      button_3_short: [3_single]\n      button_3_long: [3_long press]\n      button_3_release: [3_release]\n      button_3_double: [3_double]\n      button_3_triple: [3_triple]\n      button_4_short: [4_single]\n      button_4_long: [4_long press]\n      button_4_release: [4_release]\n      button_4_double: [4_double]\n      button_4_triple: [4_triple]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/WXCJKG12LM.html#aqara-wxcjkg12lm\n      button_1_short: [button_1_single]\n      button_1_long: [button_1_hold]\n      button_1_release: [button_1_release]\n      button_1_double: [button_1_double]\n      button_1_triple: [button_1_triple]\n      button_2_short: [button_2_single]\n      button_2_long: [button_2_hold]\n      button_2_release: [button_2_release]\n      button_2_double: [button_2_double]\n      button_2_triple: [button_2_triple]\n      button_3_short: [button_3_single]\n      button_3_long: [button_3_hold]\n      button_3_release: [button_3_release]\n      button_3_double: [button_3_double]\n      button_3_triple: [button_3_triple]\n      button_4_short: [button_4_single]\n      button_4_long: [button_4_hold]\n      button_4_release: [button_4_release]\n      button_4_double: [button_4_double]\n      button_4_triple: [button_4_triple]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_1_short: '{{ actions_mapping[integration_id][\"button_1_short\"] }}'\n  button_1_long: '{{ actions_mapping[integration_id][\"button_1_long\"] }}'\n  button_1_release: '{{ actions_mapping[integration_id][\"button_1_release\"] }}'\n  button_1_double: '{{ actions_mapping[integration_id][\"button_1_double\"] }}'\n  button_1_triple: '{{ actions_mapping[integration_id][\"button_1_triple\"] }}'\n  button_2_short: '{{ actions_mapping[integration_id][\"button_2_short\"] }}'\n  button_2_long: '{{ actions_mapping[integration_id][\"button_2_long\"] }}'\n  button_2_release: '{{ actions_mapping[integration_id][\"button_2_release\"] }}'\n  button_2_double: '{{ actions_mapping[integration_id][\"button_2_double\"] }}'\n  button_2_triple: '{{ actions_mapping[integration_id][\"button_2_triple\"] }}'\n  button_3_short: '{{ actions_mapping[integration_id][\"button_3_short\"] }}'\n  button_3_long: '{{ actions_mapping[integration_id][\"button_3_long\"] }}'\n  button_3_release: '{{ actions_mapping[integration_id][\"button_3_release\"] }}'\n  button_3_double: '{{ actions_mapping[integration_id][\"button_3_double\"] }}'\n  button_3_triple: '{{ actions_mapping[integration_id][\"button_3_triple\"] }}'\n  button_4_short: '{{ actions_mapping[integration_id][\"button_4_short\"] }}'\n  button_4_long: '{{ actions_mapping[integration_id][\"button_4_long\"] }}'\n  button_4_release: '{{ actions_mapping[integration_id][\"button_4_release\"] }}'\n  button_4_double: '{{ actions_mapping[integration_id][\"button_4_double\"] }}'\n  button_4_triple: '{{ actions_mapping[integration_id][\"button_4_triple\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_1_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_2_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_3_triple\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_single\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_hold\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_release\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_double\n  - platform: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: button_4_triple\n  # triggers for other integrations\n  - platform: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\": \\\".*\\\"|\\\"t\\\": \\d+\\.\\d+)(, )?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_1_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_short\n      - conditions: '{{ trigger_action | string in button_1_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_1_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_1_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_1_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_1_long\n      - conditions: '{{ trigger_action | string in button_1_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_release\n      - conditions: '{{ trigger_action | string in button_1_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_double\n      - conditions: '{{ trigger_action | string in button_1_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_1_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_1_triple\n      - conditions: '{{ trigger_action | string in button_2_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_short\n      - conditions: '{{ trigger_action | string in button_2_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_2_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_2_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_2_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_2_long\n      - conditions: '{{ trigger_action | string in button_2_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_release\n      - conditions: '{{ trigger_action | string in button_2_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_double\n      - conditions: '{{ trigger_action | string in button_2_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_2_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_2_triple\n      - conditions: '{{ trigger_action | string in button_3_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_short\n      - conditions: '{{ trigger_action | string in button_3_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_3_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_3_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_3_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_3_long\n      - conditions: '{{ trigger_action | string in button_3_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_release\n      - conditions: '{{ trigger_action | string in button_3_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_double\n      - conditions: '{{ trigger_action | string in button_3_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_3_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_3_triple\n      - conditions: '{{ trigger_action | string in button_4_short }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_short\n      - conditions: '{{ trigger_action | string in button_4_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_4_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_4_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_4_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_4_long\n      - conditions: '{{ trigger_action | string in button_4_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_release\n      - conditions: '{{ trigger_action | string in button_4_double }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_double\n      - conditions: '{{ trigger_action | string in button_4_triple }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_4_triple\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_4_triple\n"},6226:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation/addon_update_notification","title":"Send a mobile notification when add-on update is available","description":"Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available.","source":"@site/docs/blueprints/automation/addon_update_notification.mdx","sourceDirName":"blueprints/automation","slug":"/blueprints/automation/addon_update_notification","permalink":"/awesome-ha-blueprints/docs/blueprints/automation/addon_update_notification","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation/addon_update_notification.mdx","tags":[],"version":"current","frontMatter":{"title":"Send a mobile notification when add-on update is available","description":"Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Send a mobile notification when add-on update is available",description:"Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"How to enable add-on entities",id:"how-to-enable-add-on-entities",level:4},{value:"Inputs",id:"inputs",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"addon_update_notification",category:"automation"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"Send a notification to the provided mobile devices whenever an update for the given Home Assistant add-on is available.\nSupports full notification customization, notification groups, auto-dismissal when the add-on is updated and button for starting the update directly from your notification tray, with optional notification after the update completed succesfully.\nThis blueprint doesn't require any additional sensor to be manually set up, since it uses the built-in add-on sensors introduced with the Supervisor integration starting from Home Assistant Core 2021.4.0."}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.Kg,{name:"Home Assistant Supervisor + Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"To use this blueprint you must have an Home Assistant instance running installed as Home Assistant Managed OS or Home Assistant Supervised.\nYou can learn more about Home Assistant installation methods in the"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/installation/",children:"official Home Assistant docs"}),"."]}),(0,i.jsx)(n.p,{children:"You must also have the Home Assistant Supervisor integration enabled and correctly set up. This is available and enabled by default starting from Home Assistant Core 2021.4.0."}),(0,i.jsx)(n.p,{children:"Moreover, add-on sensors are disabled by default in the Supervisor integration. Please make sure to enable the following entities for the add-on you plan to track before setting up this blueprint:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sensor.<addon>_version"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sensor.<addon>_newest_version"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"binary_sensor.<addon>_update_available"})}),"\n"]}),(0,i.jsx)(n.h4,{id:"how-to-enable-add-on-entities",children:"How to enable add-on entities"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Navigate to ",(0,i.jsx)(n.em,{children:"Configuration"})," -> ",(0,i.jsx)(n.em,{children:"Integrations"})," in your Home Assistant UI. You can click the following button to navigate to the Integrations dashboard for your installation."]}),"\n"]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://my.home-assistant.io/redirect/integrations/",children:(0,i.jsx)(n.img,{src:"https://my.home-assistant.io/badges/integrations.svg",alt:"Open your Home Assistant instance and show your integrations."})})," 2. Click on ",(0,i.jsx)(n.em,{children:"Entities"})," in the ",(0,i.jsx)(n.em,{children:"Home Assistant Supervisor"})," card you find in the Integrations page. You'll be presented with a table of entities exposed by the Supervisor integration. 3. Select all the entities you want to use with this blueprint, then hit ",(0,i.jsx)(n.em,{children:"Enable Selected"})," on the top right of the table. 4. You've succesfully enabled the add-on entities required by this blueprint."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/hassio/",children:"Home Assistant Supervisor Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Mobile App Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the service to send notification to mobile devices. This should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/mobile_app/",children:"Mobile App Integration Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Home Assistant Companion App",required:!0,children:[(0,i.jsx)(n.p,{children:"The official mobile app for Home Assistant. Make sure to have the Home Assistant Companion App installed and configured on mobile devices you plan to use for this automation."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://companion.home-assistant.io/docs/notifications/notifications-basic#sending-notifications-to-multiple-devices",children:"Home Assistant Companion App Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Notify Group Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["If you want to simultaneously send the notification to multiple devices, you can define a notification group using this integration in your ",(0,i.jsx)(n.code,{children:"configuration.yaml"}),", then provide the service for the notification group in the ",(0,i.jsx)(n.a,{href:"#mobile-devices-notification-service",children:"Mobile devices notification service input"}),". This integration should be enabled by default. More on how to setup notification groups in the official docs."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/notify.group/",children:"Notify Group Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"automation",id:"addon_update_notification"}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsxs)(n.p,{children:["Please be aware that if you use notification groups which include both iOS and Android devices, some features (like Android Channels and notification groups) won't work. More details in the ",(0,i.jsx)(n.a,{href:"https://companion.home-assistant.io/docs/notifications/notifications-basic#sending-notifications-to-multiple-devices",children:"Home Assistant Companion App Docs"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-04-25"}),": first blueprint version ","\ud83c\udf89"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},6237:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - Philips 8718699693985 Hue Smart Button\n  description: |\n    # Controller - Philips 8718699693985 Hue Smart Button\n\n    Controller automation for executing any kind of action triggered by the provided Philips 8718699693985 Hue Smart Button. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/philips_8718699693985).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/philips_8718699693985/philips_8718699693985.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/8718699693985.html#philips-8718699693985\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue smart button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Philips\n              model: Hue smart button (8718699693985)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: Philips\n              # **TBConfirmed** model:\n            - integration: deconz\n              manufacturer: Philips\n              # **TBConfirmed** model:\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) (Virtual) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_double_press:\n      name: (Optional) Expose button double press event\n      description: Choose whether or not to expose the virtual double press event for the button. Turn this on if you are providing an action for the button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  button_double_press: !input button_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1000']\n      button_long: ['1001']\n      button_release: ['1003']\n    zha:\n      button_short: [on_short_release]\n      button_long: [on_hold]\n      button_release: [on_long_release]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/8718699693985.html#action-enum\n      button_short: [press]\n      button_long: [hold]\n      button_release: [release]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'off'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: press\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hold\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: release\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  # check that the button event is not empty\n  - >-\n    {%- set trigger_action -%}\n    {%- if integration_id == \"zigbee2mqtt\" -%}\n    {{ trigger.payload }}\n    {%- elif integration_id == \"deconz\" -%}\n    {{ trigger.event.data.event }}\n    {%- elif integration_id == \"zha\" -%}\n    {{ trigger.event.data.command }}\n    {%- endif -%}\n    {%- endset -%}\n    {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n"},6313:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/philips_929002398602","title":"Controller - Philips 929002398602 Hue Dimmer switch v2","description":"Controller automation for executing any kind of action triggered by the provided Philips 929002398602 Hue Dimmer switch v2. Supports Zigbee2MQTT, ZHA.","source":"@site/docs/blueprints/controllers/philips_929002398602.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/philips_929002398602","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/philips_929002398602","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/philips_929002398602.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Philips 929002398602 Hue Dimmer switch v2","description":"Controller automation for executing any kind of action triggered by the provided Philips 929002398602 Hue Dimmer switch v2. Supports Zigbee2MQTT, ZHA.","model":929002398602,"manufacturer":"Philips","integrations":["Zigbee2MQTT","ZHA"],"model_name":"Philips 929002398602 Hue Dimmer switch v2"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Philips 929002398602 Hue Dimmer switch v2",description:"Controller automation for executing any kind of action triggered by the provided Philips 929002398602 Hue Dimmer switch v2. Supports Zigbee2MQTT, ZHA.",model:929002398602,manufacturer:"Philips",integrations:["Zigbee2MQTT","ZHA"],model_name:"Philips 929002398602 Hue Dimmer switch v2"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"philips_929002398602",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Philips 929002398602 Hue Dimmer switch v2. Supports controllers integrated with Zigbee2MQTT or ZHA. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_929002398602#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"philips_929002398602"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"On button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"On button long press -> Color up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Off button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Off button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"On button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"On button long press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Off button short press -> Stop"}),"\n",(0,i.jsx)(n.li,{children:"Off button long press -> Previous track"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-21"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-22"}),": Fix short press actions not being triggered by quick button clicks."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},6421:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e2213","title":"Controller - IKEA E2213 SOMRIG shortcut button","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2213 SOMRIG shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e2213.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e2213","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e2213","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e2213.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E2213 SOMRIG shortcut button","description":"Controller automation for executing any kind of action triggered by the provided IKEA E2213 SOMRIG shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E2213","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E2213 SOMRIG shortcut button"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E2213 SOMRIG shortcut button",description:"Controller automation for executing any kind of action triggered by the provided IKEA E2213 SOMRIG shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E2213",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E2213 SOMRIG shortcut button"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"(Default) Mapping",id:"default-mapping",level:4},{value:"(Option 1) Mapping",id:"option-1-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"(Default) Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"(Default) Mapping",id:"default-mapping-2",level:4},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e2213",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E2213 SOMRIG shortcut button. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. The blueprint will automagically detect the integration type and take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint handles double button press events natively as it is supported by the controller device itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with lights, media players, covers and maybe more in the future. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e2213#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e2213"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"option-1-mapping",children:"(Option 1) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button double press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button double press -> Turn off"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button long press -> Volume down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"(Default) Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dots1 button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Dots1 button long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Dots2 button double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-26"}),": Initial release. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),") ","\ud83c\udf89"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},6560:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/philips_324131092621","title":"Controller - Philips 324131092621 Hue Dimmer switch","description":"Controller automation for executing any kind of action triggered by the provided Philips 324131092621 Hue Dimmer switch. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/philips_324131092621.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/philips_324131092621","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/philips_324131092621","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/philips_324131092621.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Philips 324131092621 Hue Dimmer switch","description":"Controller automation for executing any kind of action triggered by the provided Philips 324131092621 Hue Dimmer switch. Supports Zigbee2MQTT, ZHA, deCONZ.","model":324131092621,"manufacturer":"Philips","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"Philips 324131092621 Hue Dimmer switch"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Philips 324131092621 Hue Dimmer switch",description:"Controller automation for executing any kind of action triggered by the provided Philips 324131092621 Hue Dimmer switch. Supports Zigbee2MQTT, ZHA, deCONZ.",model:324131092621,manufacturer:"Philips",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"Philips 324131092621 Hue Dimmer switch"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"philips_324131092621",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Philips 324131092621 Hue Dimmer switch. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/philips_324131092621#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"philips_324131092621"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"On button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"On button long press -> Color up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Off button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Off button long press -> Color down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"On button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"On button long press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Off button short press -> Stop"}),"\n",(0,i.jsx)(n.li,{children:"Off button long press -> Previous track"}),"\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down (continuous, until release)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-27"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": Fix double press events not being detected with deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with four new blueprint inputs"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n",(0,i.jsx)(n.li,{children:"Fix for Zigbee2MQTT reporting null state changes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-11-19"}),": Fix controller events not being recognized when using ZHA."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},6957:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Example Automation Blueprint\n  description: |\n    A description for the blueprint\n\n    Version: yyyy.mm.dd\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/example/example.yaml\n  domain: automation\n  input:\n    example_input_boolean:\n      name: Example Input Boolean\n      description: A description for the example input\n      # make sure only entities from the input_boolean domain can be assigned to this input\n      selector:\n        entity:\n          domain: input_boolean\n    example_text:\n      name: (Optional) Example Text\n      description: A description for the example input\n      # wherever possible provide a default value for your inputs\n      default: Sample Text Message\n      # we want the user to provide a line of text, so we can skip the selector here\n      # this is the only situation which doesn't require a proper input selector\n    example_device:\n      name: (MQTT Integration Required) Example Input Device\n      description: A device input which demonstrates how to document an input with a specific requirement. As a bare example, this input is required only if using the MQTT Integration.\n      # wherever possible provide a default value for your inputs\n      default: ''\n      # make sure only devices can be assigned to this input\n      selector:\n        device:\n\n# Automation schema\nmode: restart\n\ntrigger:\n  platform: state\n  entity_id: !input example_input_boolean\n  from: 'off'\n  to: 'on'\ncondition: []\naction:\n  # if part of your automations are comaplicated, remember to add comments to better explain what's happening\n  service: persistent_notification.create\n  data:\n    title: This is a title\n    message: !input example_text\n"},6993:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Simple Safe Scheduler\n  description: >\n    # Simple Safe Scheduler\n\n\n    Scheduling a periodic action in Home Assistant might be trickier than what it looks at first glance. Not only the available automation triggers are limited to only time-based schedules (requiring the user to either use template triggers or install additional integrations for more complex scheduling options), but they also do not guarantee that the automation is executed at the provided time.\n\n\n    As an example, let's assume automation _A_ is scheduled to run at 12:00. If the Home Assistant server goes down at 11:59 due to a disruptive event (e.g. power outage, planned maintenance, hardware failure etc.) and comes back up at 12:01, the _A_ automation run scheduled for 12:00 would simply be skipped, without any warning to the user.\n\n\n    The Simple Safe Scheduler blueprint tries to mitigate scheduling limitations in Home Assistant by providing an easy interface to configure periodic actions, with built-in safety checks to ensure the action actually runs even in case of a disruptive event.\n\n\n    The configured automation acts as a simple scheduler, allowing to flexibly program any kind of action based on the following parameters:\n\n\n    - Time of the day (dynamically provided as an `input_datetime` entity);\n\n    - Day of the week (multiple days can be selected);\n\n    - Week frequency (allowing to schedule the action to run i.e. every 2 weeks).\n\n\n    In addition, the blueprint implements useful checks to make sure that, in case of a disruptive event (e.g power outage, Home Assistant server outage etc.) happening at the scheduled automation run time, the action is executed as soon as the system restores its state. These checks can be configured to be performed both when Home Assistant boots up and when a custom event is fired (e.g. from another automation or integration). Such safety checks might be particularly important for critical automations, which need to run as close as possible to the scheduled time (e.g. watering plants, configuring an alarm system, etc.).\n\n\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/automation/simple_safe_scheduler).\n\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**.\n\n\n    \u2139\ufe0f Version 2021.10.22\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/automation/simple_safe_scheduler/simple_safe_scheduler.yaml\n  domain: automation\n  input:\n    action:\n      name: (Required) Action\n      description: The action which needs to be executed by this automation at the provided day and time.\n      selector:\n        action:\n    helper_storage:\n      name: (Required) Helper - Storage\n      description: A text helper which will be used by the automation to store information regarding the last successful run. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      selector:\n        entity:\n          domain: input_text\n    weeks_frequency:\n      name: (Optional) Run every N weeks\n      description: The number of weeks between a successful run and the next one.\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 52\n          mode: slider\n          unit_of_measurement: weeks\n    day_monday:\n      name: (Optional) Run on Monday\n      description: Run the action on Monday.\n      default: false\n      selector:\n        boolean:\n    day_tuesday:\n      name: (Optional) Run on Tuesday\n      description: Run the action on Tuesday.\n      default: false\n      selector:\n        boolean:\n    day_wednesday:\n      name: (Optional) Run on Wednesday\n      description: Run the action on Wednesday.\n      default: false\n      selector:\n        boolean:\n    day_thursday:\n      name: (Optional) Run on Thursday\n      description: Run the action on Thursday.\n      default: false\n      selector:\n        boolean:\n    day_friday:\n      name: (Optional) Run on Friday\n      description: Run the action on Friday.\n      default: false\n      selector:\n        boolean:\n    day_saturday:\n      name: (Optional) Run on Saturday\n      description: Run the action on Saturday.\n      default: false\n      selector:\n        boolean:\n    day_sunday:\n      name: (Optional) Run on Sunday\n      description: Run the action on Sunday.\n      default: false\n      selector:\n        boolean:\n    time_entity:\n      name: (Required) Run Time Entity\n      description: 'Entity which describes the time when the action should run. Provide an entity with only time information configured (has_time: true, has_date: false).'\n      selector:\n        entity:\n          domain: input_datetime\n    custom_trigger_event:\n      name: (Optional) Custom Trigger Event\n      description: A custom event which can trigger the execution check (eg. a powercut event reported by external integrations).\n      default: ''\n      selector:\n        text:\n    trigger_at_homeassistant_startup:\n      name: (Optional) Trigger at Home Assistant startup\n      description: Trigger the execution check at Home Assistant startup.\n      default: true\n      selector:\n        boolean:\n    block_late_execution:\n      name: (Optional) Block late execution\n      description: Prevent the action to be executed too late, when a given period of time passed since the expected run time.\n      default: false\n      selector:\n        boolean:\n    block_late_execution_max_elapsed_time:\n      name: (Optional) Block late execution - Max elapsed time\n      description: 'Threshold which is used to determine a late execution: if the provided amount of time passed since the expected run time and block late execution is enabled, the action will not be executed in any case.'\n      default: 1\n      selector:\n        number:\n          min: 1\n          max: 10080\n          unit_of_measurement: minutes\n          mode: slider\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  day_monday: !input day_monday\n  day_tuesday: !input day_tuesday\n  day_wednesday: !input day_wednesday\n  day_thursday: !input day_thursday\n  day_friday: !input day_friday\n  day_saturday: !input day_saturday\n  day_sunday: !input day_sunday\n  weeks_frequency: !input weeks_frequency\n  time_entity: !input time_entity\n  helper_storage: !input helper_storage\n  trigger_at_homeassistant_startup: !input trigger_at_homeassistant_startup\n  block_late_execution: !input block_late_execution\n  block_late_execution_max_elapsed_time: !input block_late_execution_max_elapsed_time\n  # time format used by strptime\n  time_fmt: '%H:%M:%S'\n  # regex to identify whether a value represents a JSON object\n  json_regex: '^\\{(\\\".*\\\": ((\\\".*\\\")|(.*))(, )?)*\\}$'\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  # at specified time, every day\n  - id: run_time\n    platform: time\n    at:\n      - !input time_entity\n  # at home assistant startup\n  - id: homeassistant_start\n    platform: homeassistant\n    event: start\n  # when the custom event is fired\n  - id: custom_trigger_event\n    platform: event\n    event_type: !input custom_trigger_event\ncondition:\n  # if triggered by the homeassistant platform check if the automation should be run, as specified by the user\n  # if triggered by something else, just continue\n  - condition: and\n    conditions:\n      # if triggered by the run time, check that the automation is allowed to run today\n      - >-\n        {%- set today = now().weekday() -%} {{ trigger.id != \"run_time\" or today == 0 and day_monday or today == 1 and day_tuesday or today == 2 and day_wednesday or today == 3 and day_thursday or today == 4 and day_friday or today == 5 and day_saturday or today == 6 and day_sunday }}\n      # if triggered due to home assistant startup, check that the feature is enabled\n      - '{{ trigger.id != \"homeassistant_start\" or trigger_at_homeassistant_startup }}'\n      # if triggered due to home assistant startup or to a custom trigger event, perform the execution check\n      # check whether the automation run at or after the expected run time\n      # if this is the case, there's no need to run the automation again\n      # else, the automation was not able to run at the expected time, and was not executed after it, hence run it now\n      # if block late execution is enabled, check also that no more than the provided max elapsed time has passed since the expected run time\n      - >-\n        {%- set cdt = now() | as_timestamp | timestamp_local | as_datetime -%}\n        {%- set lsrdt = ((states(helper_storage) | from_json).last_triggered if (states(helper_storage) | regex_match(json_regex)) else 0) | timestamp_local | as_datetime -%}\n        {%- set idt = strptime(states(time_entity),time_fmt) -%}\n        {%- set days = [day_monday, day_tuesday, day_wednesday, day_thursday, day_friday, day_saturday, day_sunday] -%}\n        {%- set cwd = cdt.weekday() -%}\n\n        {% macro day_offset(day) -%}\n          {%- if days[day] -%}\n            {{ 7 if cwd == day and cdt.time() < idt.time() else (cwd-day)%7 }}\n          {%- else -%}\n            -1\n          {%- endif -%}\n        {%- endmacro %}\n\n        {%- set weekdays = [day_offset(0)|int, day_offset(1)|int, day_offset(2)|int, day_offset(3)|int, day_offset(4)|int, day_offset(5)|int, day_offset(6)|int] | select(\"ge\",0) | list -%}\n\n        {%- if weekdays | length > 0 -%}\n          {%- set closest_weekday = weekdays | min -%}\n          {%- set day_diff = timedelta(weeks=weeks_frequency-1, days=closest_weekday) -%}\n          {%- set edt = (cdt - day_diff - timedelta(hours=cdt.hour, minutes=cdt.minute, seconds = cdt.second) + timedelta(hours=idt.hour, minutes=idt.minute, seconds = idt.second)) | as_timestamp | timestamp_local | as_datetime -%}\n          {{ trigger.id not in [\"homeassistant_start\",\"custom_trigger_event\"] or lsrdt < edt and (not block_late_execution or edt >= cdt - timedelta(minutes=block_late_execution_max_elapsed_time))  }}\n        {%- else -%}\n          {{ false }}\n        {%- endif -%}\naction:\n  # store the current datetime into the helper, since the automation was successfully triggered\n  - service: input_text.set_value\n    data:\n      entity_id: !input helper_storage\n      value: '{{ {\"last_triggered\": now() | as_timestamp } | to_json }}'\n  # run the user provided action\n  - choose:\n      - conditions: []\n        sequence: !input action\n"},7322:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation/on_off_schedule_state_persistence","title":"On-Off schedule with state persistence","description":"A simple on-off schedule, with the addition of state persistence across disruptive events, making sure the target device is always in the expected state.","source":"@site/docs/blueprints/automation/on_off_schedule_state_persistence.mdx","sourceDirName":"blueprints/automation","slug":"/blueprints/automation/on_off_schedule_state_persistence","permalink":"/awesome-ha-blueprints/docs/blueprints/automation/on_off_schedule_state_persistence","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation/on_off_schedule_state_persistence.mdx","tags":[],"version":"current","frontMatter":{"title":"On-Off schedule with state persistence","description":"A simple on-off schedule, with the addition of state persistence across disruptive events, making sure the target device is always in the expected state."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"On-Off schedule with state persistence",description:"A simple on-off schedule, with the addition of state persistence across disruptive events, making sure the target device is always in the expected state."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"on_off_schedule_state_persistence",category:"automation"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides a simple on-off schedule, with the addition of state persistence across server reboots, powercuts, or other disruptive events which could potentially alter the expected state of the targeted entities. The automation makes sure the target is always in the expected state, even in these situations, but always leaving the freedom to manually toggle the target state as desired. It can be used on critical targets which require a simple on-off schedule during every single day."}),"\n",(0,i.jsxs)(n.p,{children:["One common scenario where this could be useful is in the case of a server reboot or shutdown. For example, let's assume you've an automation ",(0,i.jsx)(n.em,{children:"A"})," set to turn on light ",(0,i.jsx)(n.em,{children:"L"})," at 12:00. If for whatever reason Home Assistant goes offline at 11:59 and turns back on at 12:01, automation ",(0,i.jsx)(n.em,{children:"A"})," scheduled for 12:00 is not executed, with the result of ",(0,i.jsx)(n.em,{children:"L"})," not being in the state you'd expect to be, after 12:00."]}),"\n",(0,i.jsxs)(n.p,{children:["Using this blueprint in the above example would have guaranteed the expected behaviour, with the automation ",(0,i.jsx)(n.em,{children:"A"})," being run at Home Assistant startup, and setting the ",(0,i.jsx)(n.em,{children:"L"})," state as described by the schedule."]}),"\n",(0,i.jsx)(n.p,{children:"Examples of disruptive scenarios could include server reboots, network outages or powercuts. Since every installation could be influenced by many different events and check for them in many different ways, the blueprints includes the flexibility to optionally supply a custom event type which the automation will listen to. When such event is fired, the automation is run."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint already implements the support for listening to Home Assistant startup events, but this functionality can be disabled as desired by the user."}),"\n",(0,i.jsx)(n.p,{children:"Internally, the blueprint calculates time ranges based on the provided On-Off times, bound to the target expected state. Whenever one of the specified times is reached or a disruptive event occurs, the automation retrieves the expected state from the calculated ranges, and enforces it on the target."}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(n.p,{children:["No additional integrations or addons are required for this blueprint, since it's only based on the ",(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/homeassistant",children:"Home Assistant Core Integration"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"If you optionally want to supply a custom event type to the blueprint, you should setup a mechanism to fire the event in any situation a state check should be performed. This could be an integration firing an event, or another automation, so any additional required setup is out of scope of this documentation."}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"automation",id:"on_off_schedule_state_persistence"}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.p,{children:"This automation only provides a simple On-Off schedule. More complex situations could require a different approach to the problem. Also, be aware that running multiple automations generated with this blueprint against the same target could result in unexpected behaviour."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-02-01"}),": first blueprint version ","\ud83c\udf89"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. Remove default value from required inputs. No functionality change."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},7432:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/xiaomi_wxkg11lm","title":"Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch","description":"Controller automation for executing any kind of action triggered by the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/xiaomi_wxkg11lm.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/xiaomi_wxkg11lm","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxkg11lm","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/xiaomi_wxkg11lm.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch","description":"Controller automation for executing any kind of action triggered by the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.","model":["WXKG11LM","WXKG01LM"],"model_name":["Aqara WXKG11LM Wireless Mini Switch","Xiaomi WXKG01LM Mi Wireless Switch"],"manufacturer":["Aqara","Xiaomi"],"integrations":["Zigbee2MQTT","ZHA","deCONZ"]}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch",description:"Controller automation for executing any kind of action triggered by the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.",model:["WXKG11LM","WXKG01LM"],model_name:["Aqara WXKG11LM Wireless Mini Switch","Xiaomi WXKG01LM Mi Wireless Switch"],manufacturer:["Aqara","Xiaomi"],integrations:["Zigbee2MQTT","ZHA","deCONZ"]},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Support for deCONZ actions",id:"support-for-deconz-actions",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"xiaomi_wxkg11lm",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Aqara WXKG11LM Wireless Mini Switch / Xiaomi WXKG01LM Mi Wireless Switch. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxkg11lm#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"xiaomi_wxkg11lm"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Color up"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Next track"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop cover and cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Close cover"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"support-for-deconz-actions",children:"Support for deCONZ actions"}),"\n",(0,i.jsx)(n.p,{children:"Please note that this blueprint provides deCONZ support for the 2018 version of this product, having single, double, hold and release actions."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-22"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-16"}),": Add support for Xiaomi WXKG01LM Mi Wireless Switch, rename Xiaomi WXKG11LM Aqara Wireless Switch Mini to Aqara WXKG11LM Wireless Mini Switch. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},7640:(e,n,t)=>{var o={"./automation.mdx":2126,"./automation/addon_update_notification.mdx":6226,"./automation/example.mdx":9893,"./automation/on_off_schedule_state_persistence.mdx":7322,"./automation/persistent_notification_to_mobile.mdx":8539,"./automation/simple_safe_scheduler.mdx":616,"./controllers.mdx":969,"./controllers/ikea_e1524_e1810.mdx":4154,"./controllers/ikea_e1743.mdx":8516,"./controllers/ikea_e1744.mdx":4388,"./controllers/ikea_e1766.mdx":8680,"./controllers/ikea_e1812.mdx":7970,"./controllers/ikea_e2001_e2002.mdx":4605,"./controllers/ikea_e2123.mdx":5339,"./controllers/ikea_e2201.mdx":1902,"./controllers/ikea_e2213.mdx":6421,"./controllers/ikea_ictc_g_1.mdx":1044,"./controllers/osram_ac025xx00nj.mdx":5864,"./controllers/philips_324131092621.mdx":6560,"./controllers/philips_8718699693985.mdx":2478,"./controllers/philips_929002398602.mdx":6313,"./controllers/sonoff_snzb01.mdx":8663,"./controllers/tuya_ERS-10TZBVK-AA.mdx":8425,"./controllers/xiaomi_wxcjkg11lm.mdx":5630,"./controllers/xiaomi_wxcjkg12lm.mdx":2554,"./controllers/xiaomi_wxcjkg13lm.mdx":7881,"./controllers/xiaomi_wxkg11lm.mdx":7432,"./hooks.mdx":9569,"./hooks/cover.mdx":1320,"./hooks/light.mdx":1033,"./hooks/media_player.mdx":5058};function i(e){var n=r(e);return t(n)}function r(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}i.keys=function(){return Object.keys(o)},i.resolve=r,e.exports=i,i.id=7640},7881:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/xiaomi_wxcjkg13lm","title":"Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/xiaomi_wxcjkg13lm.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/xiaomi_wxcjkg13lm","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/xiaomi_wxcjkg13lm","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/xiaomi_wxcjkg13lm.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote","description":"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"WXCJKG13LM","manufacturer":"Xiaomi","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"Xiaomi WXCJKG13LM Aqara Opple 6 button remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Xiaomi WXCJKG13LM Aqara Opple 6 button remote",description:"Controller automation for executing any kind of action triggered by the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"WXCJKG13LM",manufacturer:"Xiaomi",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"Xiaomi WXCJKG13LM Aqara Opple 6 button remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Mapping #3",id:"mapping-3",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Mapping #2",id:"mapping-2-1",level:4},{value:"Mapping #3",id:"mapping-3-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Mapping #2",id:"mapping-2-2",level:4},{value:"Mapping #3",id:"mapping-3-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"xiaomi_wxcjkg13lm",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Xiaomi WXCJKG13LM Aqara Opple 6 button remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/xiaomi_wxcjkg13lm#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"xiaomi_wxcjkg13lm"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-3",children:"Mapping #3"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 5 short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Button 5 long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 5 double press -> Color up"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 double press -> Color down"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2-1",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-3-1",children:"Mapping #3"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 5 short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Button 5 long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsx)(n.li,{children:"Button 5 double press -> Next track"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 long press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 double press -> Play/Pause"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 1 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 1 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 2 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 3 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 3 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 4 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-3-2",children:"Mapping #3"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button 5 short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 5 long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 long press -> Close the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button 6 double press -> Stop cover and cover tilt"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-12-03"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},7970:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e1812","title":"Controller - IKEA E1812 TR\xc5DFRI Shortcut button","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1812 TR\xc5DFRI Shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e1812.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e1812","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e1812.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E1812 TR\xc5DFRI Shortcut button","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1812 TR\xc5DFRI Shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E1812","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E1812 TR\xc5DFRI Shortcut button"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E1812 TR\xc5DFRI Shortcut button",description:"Controller automation for executing any kind of action triggered by the provided IKEA E1812 TR\xc5DFRI Shortcut button. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E1812",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E1812 TR\xc5DFRI Shortcut button"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e1812",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E1812 TR\xc5DFRI Shortcut button. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1812#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e1812"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Toggle"}),"\n",(0,i.jsxs)(n.li,{children:["Button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color up"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop"}),"\n",(0,i.jsxs)(n.li,{children:["Button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop cover and cover tilt"}),"\n",(0,i.jsxs)(n.li,{children:["Button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Close cover"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-14"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),": ","\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": standardize input names across all the Controller blueprints.\nIf you plan to update this blueprint, please update the inputs in your automations as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_device"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zigbee2mqtt_remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_entity"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helper_last_loop_event_input"})," -> ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": add support for the Cover Hook"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": Fix double press events not being detected with deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-15"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with a new blueprint input"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),": Fix for Zigbee2MQTT reporting null state changes"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-03"}),": Fixed double press events not triggered due to changes in Home Assistant 2023.5.x."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8425:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/tuya_ERS-10TZBVK-AA","title":"Controller - Tuya ERS-10TZBVK-AA Smart knob","description":"Controller automation for executing any kind of action triggered by the provided Tuya ERS-10TZBVK-AA Smart knob. Supports Zigbee2MQTT, ZHA.","source":"@site/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/tuya_ERS-10TZBVK-AA","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - Tuya ERS-10TZBVK-AA Smart knob","description":"Controller automation for executing any kind of action triggered by the provided Tuya ERS-10TZBVK-AA Smart knob. Supports Zigbee2MQTT, ZHA.","model":"ERS-10TZBVK-AA","manufacturer":"Tuya","integrations":["Zigbee2MQTT","ZHA"],"model_name":"Tuya ERS-10TZBVK-AA Smart knob"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - Tuya ERS-10TZBVK-AA Smart knob",description:"Controller automation for executing any kind of action triggered by the provided Tuya ERS-10TZBVK-AA Smart knob. Supports Zigbee2MQTT, ZHA.",model:"ERS-10TZBVK-AA",manufacturer:"Tuya",integrations:["Zigbee2MQTT","ZHA"],model_name:"Tuya ERS-10TZBVK-AA Smart knob"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Device Modes",id:"device-modes",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"tuya_ERS-10TZBVK-AA",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided Tuya ERS-10TZBVK-AA Smart knob. Supports controllers integrated with Zigbee2MQTT, ZHA. The blueprint will automagically detect the integration type and take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"This device operates in two modes, event mode and command mode. Three presses/clicks on the remotes button will switch between the two modes."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events when in command mode, which are not exposed by the controller device itself. However, It needs to be enabled in the blueprint.\nWhen in event mode, double presses are native."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with lights, media players, covers and maybe more in the future. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"tuya_ERS-10TZBVK-AA"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Brightness down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Brightness up (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Remote short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Remote left with press [Only in Command Mode] -> Color down"}),"\n",(0,i.jsx)(n.li,{children:"Remote right with press [Only in Command Mode] -> Color up"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rotate left -> Volume down (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Rotate right -> Volume up (continuous, until stop)"}),"\n",(0,i.jsx)(n.li,{children:"Remote short press -> Play/Pause"}),"\n",(0,i.jsxs)(n.li,{children:["Remote double press [",(0,i.jsx)(n.code,{children:"Virtual"})," in Command Mode] -> Next track"]}),"\n",(0,i.jsx)(n.li,{children:"Remote long press -> Previous track"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"device-modes",children:"Device Modes"}),"\n",(0,i.jsx)(n.p,{children:"This device operates in two modes, event mode and command mode. Three presses/clicks on the remotes button will switch between the two modes.\nWhen in event mode, double presses are native.\nwhen in command mode, double presses are virtual and needs to be enabled.\nWhen in command mode, two additional features are enabled which are left and right while pressing down on the button at same time."}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's important to note that the controller doesn't natively support double press events when in command mode. Instead, this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),".\nWhen in event mode, double presses are native."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2025-03-29"}),": Initial release. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),") ","\ud83c\udf89"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8516:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e1743","title":"Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e1743.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e1743","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1743","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e1743.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E1743","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer",description:"Controller automation for executing any kind of action triggered by the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E1743",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e1743",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"In addition of being able to provide custom actions for every kind of button press supported by the remote, the blueprint allows to loop the long press actions while the corresponding button is being held. Once released, the loop stops. This is useful when holding down a button should result in a continuous action (such as lowering the volume of a media player, or controlling a light brightness)."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1743#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e1743"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Turn on"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color up"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Turn off"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color down"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Brightness up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn on"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Brightness down (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn off"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Volume up (continuous, until release)"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Volume down"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Play/Pause"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Up button long press -> Open the cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Close cover"}),"\n",(0,i.jsx)(n.li,{children:"Down button long press -> Close the cover tilt"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Stop cover and cover tilt"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The helper is used to determine button release events when the controller is integrated with Zigbee2MQTT, ZHA, because of the actions mapping for the controller with these integrations. Natively, the controller doesn't allow to distinguish between different button release events, so the blueprint must store the previous clicked button."}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-07"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-07"}),": fix an issue on Zigbee2MQTT triggering rules"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-07"}),": fix an issue which prevented to create automations for ZHA or deCONZ (thanks @kks36! ","\ud83c\udf89"," )."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-08"}),": update example, fix an issue which executed actions twice when the remote was connected via Zigbee2MQTT."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-02-23"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"add support for virtual double press events"}),"\n",(0,i.jsx)(n.li,{children:"block automation runs for empty and repeated messages"}),"\n",(0,i.jsxs)(n.li,{children:["reduce ",(0,i.jsx)(n.code,{children:"input_text helper"})," writes"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-03"}),": move the blueprint in the Controllers-Hooks Ecosystem. See announcement ",(0,i.jsx)(n.a,{href:"https://community.home-assistant.io/t/awesome-ha-blueprints-a-curated-list-of-blueprints-easily-create-controller-based-automations-remotes-switches-for-controlling-lights-media-players-and-more/256687/7",children:"here"}),". ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-25"}),": ","\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),": standardize input names across all the Controller blueprints.\nIf you plan to update this blueprint, please update the inputs in your automations as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_device"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zigbee2mqtt_remote"})," -> ",(0,i.jsx)(n.code,{children:"controller_entity"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"action_*"})," inputs -> ",(0,i.jsx)(n.code,{children:"action_button_*"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"helper_last_loop_event_input"})," -> ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-03-26"}),": add support for the Cover Hook"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-19"}),": Fix double press events not being detected with deCONZ"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-04-23"}),": Fix deCONZ events not being recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-05-26"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," is now a mandatory input. It also simplifies the blueprint setup (reducing issues due to improper configuration missing the helper, which was required only in certain conditions as was stated in the docs), and provides support for advanced features which might be developed in the future."]}),"\n",(0,i.jsxs)(n.p,{children:["If you plan to update this blueprint, please make sure to provide a valid ",(0,i.jsx)(n.code,{children:"input_text"})," entity for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," input. You should create a separate ",(0,i.jsx)(n.code,{children:"input_text"})," for each Controller blueprint you're configuring, since using the same for multiple automation could lead to inconsistencies and undefined behaviour."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Other changes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83c\udf89"," Add Debouncing support. Debouncing avoids duplicate action runs which might occur with certain controllers and integrations. The feature is disabled by default, check the documentation to find out how to enable it"]}),"\n",(0,i.jsx)(n.li,{children:"Prevent undesired endless loops, which might occur in rare cases when the corresponding stop event is not received, by running loop actions a finite number of times, customizable with two new blueprint inputs"}),"\n",(0,i.jsx)(n.li,{children:"Fix inputs wrongly marked as required"}),"\n",(0,i.jsx)(n.li,{children:"Fix for Zigbee2MQTT reporting null state changes"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-07-04"}),": Fix deCONZ button release events not being properly recognized"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-08-02"}),": Improve inputs documentation and organization"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-02"}),": Remove spaces to match new helper format in Home Assistant 2023.5.x. (",(0,i.jsx)(n.a,{href:"https://github.com/LordSushiPhoenix",children:"@LordSushiPhoenix"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-01-23"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-04-01"}),": Fix double-click detection logic. (",(0,i.jsx)(n.a,{href:"https://github.com/danleongjy",children:"@danleongjy"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8539:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation/persistent_notification_to_mobile","title":"Send Web UI persistent notifications to Mobile Devices","description":"Send Web UI persistent notifications with the provided ID to the specified Mobile Devices.","source":"@site/docs/blueprints/automation/persistent_notification_to_mobile.mdx","sourceDirName":"blueprints/automation","slug":"/blueprints/automation/persistent_notification_to_mobile","permalink":"/awesome-ha-blueprints/docs/blueprints/automation/persistent_notification_to_mobile","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation/persistent_notification_to_mobile.mdx","tags":[],"version":"current","frontMatter":{"title":"Send Web UI persistent notifications to Mobile Devices","description":"Send Web UI persistent notifications with the provided ID to the specified Mobile Devices."}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Send Web UI persistent notifications to Mobile Devices",description:"Send Web UI persistent notifications with the provided ID to the specified Mobile Devices."},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"persistent_notification_to_mobile",category:"automation"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:["This blueprint enables to send Web UI persistent notifications, (ie. the ones created with the ",(0,i.jsx)(n.code,{children:"persistent_notification.create"})," service) to the specified mobile device or device group. It also provides the option to choose which notifications must be forwarded, based on the provided notification ID."]}),"\n",(0,i.jsx)(n.p,{children:"Working both on iOS and Android devices, mobile notifications can then be organized into a specific group. For Android devices, they can also be assigned to a specific channel (for applying custom notification settings such as sound, vibration, etc.)."}),"\n",(0,i.jsx)(n.p,{children:"This blueprint can be useful in all situations when a web interface persistent notification is desired but the event should be reported also on a mobile device."}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, it can be handy in scenarios when a notification cannot be sent directly to a mobile device, for example for system generated persistent notifications (invalid login attempts, integration setup required, supervisor alerts, etc.) and for integrations/addons which, instead of providing a custom event for triggering automations, use the ",(0,i.jsx)(n.code,{children:"persistent_notification.create"})," service as an event report mechanism."]}),"\n",(0,i.jsx)(n.p,{children:"Once opened on the mobile device, the relative persistent notification in the web UI is not dismissed."}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.Kg,{name:"Persistent Notification Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"You must have this integration enabled on your system to run the automation, since the notifications on the web interface are generated by this integration. This should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/persistent_notification/",children:"Persistent Notification Integration Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Mobile App Integration",required:!0,children:[(0,i.jsx)(n.p,{children:"This integration provides the service to send notification to mobile devices. This should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/mobile_app/",children:"Mobile App Integration Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Home Assistant Companion App",required:!0,children:[(0,i.jsx)(n.p,{children:"The official mobile app for Home Assistant. Make sure to have the Home Assistant Companion App installed and configured on mobile devices you plan to use for this automation."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://companion.home-assistant.io/docs/notifications/notifications-basic#sending-notifications-to-multiple-devices",children:"Home Assistant Companion App Docs"})})]}),"\n",(0,i.jsxs)(s.Kg,{name:"Notify Group Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["If you want to simultaneously send the notification to multiple devices, you can define a notification group using this integration in your ",(0,i.jsx)(n.code,{children:"configuration.yaml"}),", then provide the service for the notification group in the ",(0,i.jsx)(n.a,{href:"#mobile-devices-notification-service",children:"Mobile devices notification service input"}),". This integration should be enabled by default. More on how to setup notification groups in the official docs."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/notify.group/",children:"Notify Group Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"automation",id:"persistent_notification_to_mobile"}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsxs)(n.p,{children:["Please be aware that if you use notification groups which include both iOS and Android devices, some features (like Android Channels and notification groups) don't work. More details in the ",(0,i.jsx)(n.a,{href:"https://companion.home-assistant.io/docs/notifications/notifications-basic#sending-notifications-to-multiple-devices",children:"Home Assistant Companion App Docs"})]}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-02-01"}),": first blueprint version ","\ud83c\udf89"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"2021-10-26"}),": Standardize blueprints structure and inputs naming across the whole collection. Improve blueprint documentation. No functionality change."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8663:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/sonoff_snzb01","title":"Controller - SONOFF SNZB-01 Wireless Switch","description":"Controller automation for executing any kind of action triggered by the provided SONOFF SNZB-01 Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/sonoff_snzb01.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/sonoff_snzb01","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/sonoff_snzb01","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/sonoff_snzb01.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - SONOFF SNZB-01 Wireless Switch","description":"Controller automation for executing any kind of action triggered by the provided SONOFF SNZB-01 Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"SNZB-01","manufacturer":"SONOFF","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"SONOFF SNZB-01 Wireless Switch"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - SONOFF SNZB-01 Wireless Switch",description:"Controller automation for executing any kind of action triggered by the provided SONOFF SNZB-01 Wireless Switch. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"SNZB-01",manufacturer:"SONOFF",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"SONOFF SNZB-01 Wireless Switch"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Behaviour of button long press",id:"behaviour-of-button-long-press",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"sonoff_snzb01",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided SONOFF SNZB-01 Wireless Switch. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/sonoff_snzb01#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"sonoff_snzb01"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Toggle"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Color up"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Play/Pause"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Next track"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Button long press -> Stop cover and cover tilt"}),"\n",(0,i.jsx)(n.li,{children:"Button double press -> Close cover"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"behaviour-of-button-long-press",children:"Behaviour of button long press"}),"\n",(0,i.jsx)(n.p,{children:"Please note that the long press action for this controller is triggered after the button is pressed and held for approximately 3 seconds. Since the device does not fire an event when the button is released, the blueprint does not support looping an action over a long press."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-07-30"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8680:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/controllers/ikea_e1766","title":"Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1766 TR\xc5DFRI Open/Close Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","source":"@site/docs/blueprints/controllers/ikea_e1766.mdx","sourceDirName":"blueprints/controllers","slug":"/blueprints/controllers/ikea_e1766","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1766","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/controllers/ikea_e1766.mdx","tags":[],"version":"current","frontMatter":{"title":"Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote","description":"Controller automation for executing any kind of action triggered by the provided IKEA E1766 TR\xc5DFRI Open/Close Remote. Supports Zigbee2MQTT, ZHA, deCONZ.","model":"E1766","manufacturer":"IKEA","integrations":["Zigbee2MQTT","ZHA","deCONZ"],"model_name":"IKEA E1766 TR\xc5DFRI Open/Close Remote"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Controller - IKEA E1766 TR\xc5DFRI Open/Close Remote",description:"Controller automation for executing any kind of action triggered by the provided IKEA E1766 TR\xc5DFRI Open/Close Remote. Supports Zigbee2MQTT, ZHA, deCONZ.",model:"E1766",manufacturer:"IKEA",integrations:["Zigbee2MQTT","ZHA","deCONZ"],model_name:"IKEA E1766 TR\xc5DFRI Open/Close Remote"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Light",id:"light",level:3},{value:"Default Mapping",id:"default-mapping",level:4},{value:"Mapping #2",id:"mapping-2",level:4},{value:"Media Player",id:"media-player",level:3},{value:"Default Mapping",id:"default-mapping-1",level:4},{value:"Cover",id:"cover",level:3},{value:"Default Mapping",id:"default-mapping-2",level:4},{value:"Additional Notes",id:"additional-notes",level:2},{value:"Helper - Last Controller Event",id:"helper---last-controller-event",level:3},{value:"Virtual double press events",id:"virtual-double-press-events",level:3},{value:"Hooks support and missing long press events",id:"hooks-support-and-missing-long-press-events",level:3},{value:"Changelog",id:"changelog",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"ikea_e1766",category:"controllers"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["This blueprint is part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"This blueprint provides universal support for running any custom action when a button is pressed on the provided IKEA E1766 TR\xc5DFRI Open/Close Remote. Supports controllers integrated with Zigbee2MQTT, ZHA, deCONZ. Just specify the integration used to connect the remote to Home Assistant when setting up the automation, and the blueprint will take care of all the rest."}),"\n",(0,i.jsx)(n.p,{children:"The blueprint also adds support for virtual double button press events, which are not exposed by the controller itself."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Automations created with this blueprint can be connected with one or more ",(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks",children:"Hooks"})," supported by this controller.\nHooks allow to easily create controller-based automations for interacting with media players, lights, covers and more. See the list of ",(0,i.jsx)(n.a,{href:"/docs/blueprints/controllers/ikea_e1766#available-hooks",children:"Hooks available for this controller"})," for additional details."]})}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(s.Kg,{id:"zigbee2mqtt"}),"\n",(0,i.jsx)(s.Kg,{id:"zha"}),"\n",(0,i.jsx)(s.Kg,{id:"deconz"}),"\n",(0,i.jsxs)(s.Kg,{name:"Input Text Integration",required:!0,children:[(0,i.jsxs)(n.p,{children:["This integration provides the entity which must be provided to the blueprint in the ",(0,i.jsx)(n.strong,{children:"Helper - Last Controller Event"})," input. Learn more about this helper by reading the dedicated section in the ",(0,i.jsx)(n.a,{href:"#helper---last-controller-event",children:"Additional Notes"}),"."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/input_text/",children:"Input Text Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"controllers",id:"ikea_e1766"}),"\n",(0,i.jsx)(n.h2,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,i.jsx)(n.admonition,{title:"Virtual double press actions",type:"note",children:(0,i.jsx)(n.p,{children:"Some of the following mappings might include actions for virtual double press events, which are disabled by default.\nIf you are using a hook mapping which provides an action for a virtual double press event, please make sure to enable support for virtual double press on the corresponding buttons with the corresponding blueprint input."})}),"\n",(0,i.jsx)(n.h3,{id:"light",children:"Light"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a light. Supports brightness and color control both for white temperature and rgb lights."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn on"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Turn off"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"mapping-2",children:"Mapping #2"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Brightness up"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color up"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Brightness down"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Color down"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/light",children:"Light Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"media-player",children:"Media Player"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a media player. Supports volume setting, play/pause and track selection."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-1",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Volume up"}),"\n",(0,i.jsxs)(n.li,{children:["Up button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Next track"]}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Volume down"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Play/Pause"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/media_player",children:"Media Player Hook docs"})}),"\n",(0,i.jsx)(n.h3,{id:"cover",children:"Cover"}),"\n",(0,i.jsx)(n.p,{children:"This Hook blueprint allows to build a controller-based automation to control a cover. Supports opening, closing and tilting the cover."}),"\n",(0,i.jsx)(n.h4,{id:"default-mapping-2",children:"Default Mapping"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Up button short press -> Open cover"}),"\n",(0,i.jsx)(n.li,{children:"Down button short press -> Close cover"}),"\n",(0,i.jsxs)(n.li,{children:["Down button double press ",(0,i.jsx)(n.code,{children:"Virtual"})," -> Stop cover and cover tilt"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/docs/blueprints/hooks/cover",children:"Cover Hook docs"})}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.h3,{id:"helper---last-controller-event",children:"Helper - Last Controller Event"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," (Helper - Last Controller Event) input serves as a permanent storage area for the automation. The stored info is used to implement the blueprint's core functionality. To learn more about the helper, how it's used and why it's required, you can read the dedicated section in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#helper---last-controller-event-input",children:"Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"virtual-double-press-events",children:"Virtual double press events"}),"\n",(0,i.jsxs)(n.p,{children:["It's also important to note that the controller doesn't natively support double press events. Instead , this blueprint provides virtual double press events. You can read more about them in the ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem#virtual-events",children:"general Controllers-Hooks Ecosystem documentation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"hooks-support-and-missing-long-press-events",children:"Hooks support and missing long press events"}),"\n",(0,i.jsx)(n.p,{children:"Due to the controller not exposing long press events but only short and release events, it's not possible to determine the nature of a button press. Therefore, to prevent an erroneous behaviour, Hooks only rely on short and virtual double press events to implement their functionality for this controller."}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2021-10-29"}),": first blueprint version ","\ud83c\udf89"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2022-08-08"}),": Optimize characters usage for the ",(0,i.jsx)(n.code,{children:"helper_last_controller_event"})," text input."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-02-13"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,i.jsx)(n.strong,{children:"Breaking Change"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Migrate to Zigbee2MQTT MQTT Device Triggers. (",(0,i.jsx)(n.a,{href:"https://github.com/yarafie",children:"@yarafie"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"controller_entity"})," input has been deprecated, and ",(0,i.jsx)(n.code,{children:"controller_device"})," is now mandatory.\nIf you are a Zigbee2MQTT user and plan to update this blueprint, please make sure to remove the ",(0,i.jsx)(n.code,{children:"controller_entity"})," input from your automation config and add the device ID of your controller to the ",(0,i.jsx)(n.code,{children:"controller_device"})," input.\nTo obtain the device ID from your controller, configure the automation from the UI and use the device selector dropdown on the ",(0,i.jsx)(n.code,{children:"controller_device"})," input to select your controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-03-20"}),": Standardized input naming format for controller devices and virtual button actions. No functionality changes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"2025-04-01"}),": Fix double-click detection logic. (",(0,i.jsx)(n.a,{href:"https://github.com/danleongjy",children:"@danleongjy"}),")"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8861:e=>{"use strict";e.exports="# Blueprint Metadata\nblueprint:\n  name: Controller - Tuya ERS-10TZBVK-AA Smart knob\n  description: |\n    # Controller - Tuya ERS-10TZBVK-AA Smart knob\n\n    Controller automation for executing any kind of action triggered by the provided Tuya ERS-10TZBVK-AA Smart knob.\n    Allows to optionally loop an action on a button long press.\n    The blueprint also adds support for virtual double button press events, which are not exposed by the controller device itself. However, It needs to be enabled in the blueprint.\n    Supports Zigbee2MQTT, ZHA.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with lights, covers, media players, and potentially more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA#available-hooks) for additional details.\n\n    A small note, avoid using both custom actions and Hooks in the same blueprint, otherwise strange things may occur.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.29\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/tuya_ERS-10TZBVK-AA).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/tuya_ERS-10TZBVK-AA/tuya_ERS-10TZBVK-AA.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  # Device Selector\n  input:\n    controller_device:\n      name: (Required) (Zigbee2MQTT, ZHA) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with Zigbee2MQTT, ZHA.\n      default: ''\n      selector:\n        # source: https://zigbee.blakadder.com/Eardatek_ERS-10TZBVK-AA.html\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/ERS-10TZBVK-AA.html#tuya-ers-10tzbvk-aa\n            - integration: mqtt\n              manufacturer: Tuya\n              model: Smart knob\n            # For backwards compatibility with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: Tuya\n              model: Smart knob (ERS-10TZBVK-AA)\n            # source: https://github.com/zigpy/zha-device-handlers/blob/b87ac8907765303c915b19d915a1ca5ea9a8bdae/zhaquirks/tuya/ts004f.py#L69\n            - integration: zha\n              manufacturer: _TZ3000_4fjiwweb\n              model: TS004F\n            - integration: zha\n              manufacturer: _TZ3000_qja6nq5z\n              model: TS004F\n            - integration: zha\n              manufacturer: _TZ3000_ixla93vd\n              model: TS004F\n          multiple: false\n    # inputs for custom actions\n    action_rotate_left:\n      name: (Optional) Rotate left\n      description: Action to run on rotate left.\n      default: []\n      selector:\n        action:\n    action_rotate_right:\n      name: (Optional) Rotate right\n      description: Action to run on rotate right.\n      default: []\n      selector:\n        action:\n    action_rotate_left_withpress:\n      name: (Optional) Rotate left_withpress\n      description: Action to run on rotate left_withpress.\n      default: []\n      selector:\n        action:\n    action_rotate_right_withpress:\n      name: (Optional) Rotate right_withpress\n      description: Action to run on rotate right_withpress.\n      default: []\n      selector:\n        action:\n    action_click_short:\n      name: (Optional) Remote short press\n      description: Action to run on short remote press.\n      default: []\n      selector:\n        action:\n    action_click_double:\n      name: (Optional) Remote double press\n      description: Action to run on double remote press.\n      default: []\n      selector:\n        action:\n    action_click_long:\n      name: (Optional) Remote long press\n      description: Action to run on long remote press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    long_press_options_section:\n      name: Long Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        click_long_loop:\n          name: (Optional) Click long - loop until stop\n          description: Loop the click long action until the rotation is stopped.\n          default: false\n          selector:\n            boolean:\n        click_long_max_loop_repeats:\n          name: (Optional) Click long - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 500\n          selector:\n            number:\n              min: 1\n              max: 5000\n              mode: slider\n              step: 1\n        rotate_left_loop:\n          name: (Optional) Rotate left - loop until stop\n          description: Loop the rotate left action until the rotation is stopped.\n          default: false\n          selector:\n            boolean:\n        rotate_left_max_loop_repeats:\n          name: (Optional) Rotate left - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 500\n          selector:\n            number:\n              min: 1\n              max: 5000\n              mode: slider\n              step: 1\n        rotate_right_loop:\n          name: (Optional) Rotate right - loop until stop\n          description: Loop the rotate right action until the rotation is stopped.\n          default: false\n          selector:\n            boolean:\n        rotate_right_max_loop_repeats:\n          name: (Optional) Rotate right - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 500\n          selector:\n            number:\n              min: 1\n              max: 5000\n              mode: slider\n              step: 1\n        rotate_left_withpress_loop:\n          name: (Optional) Rotate left_withpress - loop until stop\n          description: Loop the rotate left_withpress action until the rotation is stopped.\n          default: false\n          selector:\n            boolean:\n        rotate_left_withpress_max_loop_repeats:\n          name: (Optional) Rotate left_withpress - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 500\n          selector:\n            number:\n              min: 1\n              max: 5000\n              mode: slider\n              step: 1\n        rotate_right_withpress_loop:\n          name: (Optional) Rotate right_withpress - loop until stop\n          description: Loop the rotate right_withpress action until the rotation is stopped.\n          default: false\n          selector:\n            boolean:\n        rotate_right_withpress_max_loop_repeats:\n          name: (Optional) Rotate right_withpress - Maximum loop repeats\n          description: >-\n            Maximum number of repeats for the custom action, when looping is enabled.\n            Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n          default: 500\n          selector:\n            number:\n              min: 1\n              max: 5000\n              mode: slider\n              step: 1\n        helper_long_press_delay:\n          name: (Optional) Helper - Long Press delay\n          description: Max delay between the pushing and releasing of a button long press event. Increase this value if you notice that the long press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n    # inputs for enabling double press events\n    double_press_options_section:\n      name: Double Press options\n      icon: mdi:remote\n      collapsed: true\n      input:\n        # helper used to properly adjust the remote button double press events\n        click_double_press_exposed:\n          name: (Optional) Expose up button double press event\n          description: Choose whether or not to expose the virtual double press event for the up button. Turn this on if you are providing an action for the up button double press event.\n          default: false\n          selector:\n            boolean:\n        helper_double_press_delay:\n          name: (Optional) Helper - Double Press delay\n          description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n          default: 250\n          selector:\n            number:\n              min: 100.0\n              max: 5000.0\n              unit_of_measurement: milliseconds\n              mode: box\n              step: 10.0\n#\n# Automation schema\nvariables:\n  # Controller ID\n  controller_id: !input controller_device\n  # integration id used to select items in the action mapping\n  # integration type is set from trigger.id\n  integration_id: '{{ trigger.id.split(\"-\")[0] }}'\n  # convert input tags to variables, to be used in templates\n  click_long_loop: !input click_long_loop\n  click_long_max_loop_repeats: !input click_long_max_loop_repeats\n  rotate_left_loop: !input rotate_left_loop\n  rotate_left_max_loop_repeats: !input rotate_left_max_loop_repeats\n  rotate_right_loop: !input rotate_right_loop\n  rotate_right_max_loop_repeats: !input rotate_right_max_loop_repeats\n  rotate_left_withpress_loop: !input rotate_left_withpress_loop\n  rotate_left_withpress_max_loop_repeats: !input rotate_left_withpress_max_loop_repeats\n  rotate_right_withpress_loop: !input rotate_right_withpress_loop\n  rotate_right_withpress_max_loop_repeats: !input rotate_right_withpress_max_loop_repeats\n  helper_long_press_delay: !input helper_long_press_delay\n  click_double_press_exposed: !input click_double_press_exposed\n  helper_double_press_delay: !input helper_double_press_delay\n  # mapping between actions and integrations\n  actions_mapping:\n    z2m:\n      # source: https://www.zigbee2mqtt.io/devices/ERS-10TZBVK-AA.html#tuya-ers-10tzbvk-aa\n      # EVENT MODE\n      rotate_left_evnt: [rotate_left]\n      rotate_right_evnt: [rotate_right]\n      click_short_evnt: [single]\n      click_double_evnt: [double]\n      click_long_evnt: [hold]\n      # COMMAND MODE\n      rotate_left_cmnd: [brightness_step_down]\n      rotate_right_cmnd: [brightness_step_up]\n      rotate_left_withpress_cmnd: [color_temperature_step_down]\n      rotate_right_withpress_cmnd: [color_temperature_step_up]\n      click_short_cmnd: [toggle]\n      click_long_cmnd: [hue_move]\n      click_release_cmnd: [hue_stop]\n    zha:\n      # source: https://github.com/zigpy/zha-device-handlers/blob/b87ac8907765303c915b19d915a1ca5ea9a8bdae/zhaquirks/tuya/ts004f.py#L69\n      # EVENT MODE\n      rotate_left_evnt: [left]\n      rotate_right_evnt: [right]\n      click_short_evnt: [remote_button_short_press]\n      click_double_evnt: [remote_button_double_press]\n      click_long_evnt: [remote_button_long_press]\n      # COMMAND MODE\n      rotate_left_cmnd: [step]\n      rotate_right_cmnd: [step]\n      rotate_left_withpress_cmnd: [step_color_temp]\n      rotate_right_withpress_cmnd: [step_color_temp]\n      click_short_cmnd: [toggle]\n      click_long_cmnd: [move_hue]\n      click_release_cmnd: [stop_move_step]\n  # pre-choose actions for buttons based on configured integration\n  # mainly used to pass to hooks through ahb_controller_event\n  # EVENT MODE\n  rotate_left_evnt: '{{ actions_mapping[integration_id][\"rotate_left_evnt\"] }}'\n  rotate_right_evnt: '{{ actions_mapping[integration_id][\"rotate_right_evnt\"] }}'\n  click_short_evnt: '{{ actions_mapping[integration_id][\"click_short_evnt\"] }}'\n  click_double_evnt: '{{ actions_mapping[integration_id][\"click_double_evnt\"] }}'\n  click_long_evnt: '{{ actions_mapping[integration_id][\"click_long_evnt\"] }}'\n  # COMMAND MODE\n  rotate_left_cmnd: '{{ actions_mapping[integration_id][\"rotate_left_cmnd\"] }}'\n  rotate_right_cmnd: '{{ actions_mapping[integration_id][\"rotate_right_cmnd\"] }}'\n  rotate_left_withpress_cmnd: '{{ actions_mapping[integration_id][\"rotate_left_withpress_cmnd\"] }}'\n  rotate_right_withpress_cmnd: '{{ actions_mapping[integration_id][\"rotate_right_withpress_cmnd\"] }}'\n  click_short_cmnd: '{{ actions_mapping[integration_id][\"click_short_cmnd\"] }}'\n  click_long_cmnd: '{{ actions_mapping[integration_id][\"click_long_cmnd\"] }}'\n  click_release_cmnd: '{{ actions_mapping[integration_id][\"click_release_cmnd\"] }}'\n#\n# Mode Block\nmode: single\nmax_exceeded: silent\n#\n# Triggers Block\ntriggers:\n  # triggers for zigbee2mqtt\n  # event mode\n  - trigger: device\n    id: z2m-rotate-left-evnt\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: rotate_left\n  - trigger: device\n    id: z2m-rotate-right-evnt\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: rotate_right\n  - trigger: device\n    id: z2m-click-short-evnt\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: single\n  - trigger: device\n    id: z2m-click-double-evnt\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: double\n  - trigger: device\n    id: z2m-click-long-evnt\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hold\n  # command mode\n  - trigger: device\n    id: z2m-rotate-left-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_down\n  - trigger: device\n    id: z2m-rotate-right-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_step_up\n  - trigger: device\n    id: z2m-rotate-left-withpress-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: color_temperature_step_down\n  - trigger: device\n    id: z2m-rotate-right-withpress-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: color_temperature_step_up\n  - trigger: device\n    id: z2m-click-short-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: toggle\n  - trigger: device\n    id: z2m-click-long-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hue_move\n  - trigger: device\n    id: z2m-click-long-stop-cmnd\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: hue_stop\n  # triggers for ZHA\n  # event mode\n  - trigger: event\n    id: zha-rotate-left-evnt\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: left\n  - trigger: event\n    id: zha-rotate-right-evnt\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: right\n  - trigger: event\n    id: zha-click-short-evnt\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: remote_button_short_press\n  - trigger: event\n    id: zha-click-double-evnt\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: remote_button_double_press\n  - trigger: event\n    id: zha-click-long-evnt\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: remote_button_long_press\n  # command mode\n  - trigger: event\n    id: zha-rotate-left-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step\n      endpoint_id: 1\n      cluster_id: 8\n      args: [1]\n  - trigger: event\n    id: zha-rotate-right-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step\n      endpoint_id: 1\n      cluster_id: 8\n      args: [0]\n  - trigger: event\n    id: zha-rotate-left-withpress-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step_color_temp\n      endpoint_id: 1\n      cluster_id: 768\n      args: [3]\n  - trigger: event\n    id: zha-rotate-right-withpress-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: step_color_temp\n      endpoint_id: 1\n      cluster_id: 768\n      args: [1]\n  - trigger: event\n    id: zha-click-short-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: toggle\n      endpoint_id: 1\n      cluster_id: 6\n  - trigger: event\n    id: zha-click-long-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: move_hue\n      endpoint_id: 1\n      cluster_id: 768\n  - trigger: event\n    id: zha-click-long-stop-cmnd\n    event_type: zha_event\n    event_data:\n      device_id: !input controller_device\n      command: stop_move_step\n      endpoint_id: 1\n      cluster_id: 768\n#\n# Conditions Block\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"z2m\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\",\"unknown\"] }}\n#\n# Actions Block\nactions:\n  #\n  # choose the sequence to run based on the received button event\n  - choose:\n      #\n      # Actions for Left Rotate [Event and Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-rotate-left-evnt\n              - zha-rotate-left-evnt\n              - z2m-rotate-left-cmnd\n              - zha-rotate-left-cmnd\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ rotate_left_loop }}'\n                sequence:\n                  - repeat:\n                      count: !input rotate_left_max_loop_repeats\n                      sequence: !input action_rotate_left\n      #\n      # Actions for Right Rotate [Event and Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-rotate-right-evnt\n              - zha-rotate-right-evnt\n              - z2m-rotate-right-cmnd\n              - zha-rotate-right-cmnd\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ rotate_right_loop }}'\n                sequence:\n                  - repeat:\n                      count: !input rotate_right_max_loop_repeats\n                      sequence: !input action_rotate_right\n      #\n      # Actions for Left With Press Rotate [Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-rotate-left-withpress-cmnd\n              - zha-rotate-left-withpress-cmnd\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_left_withpress\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_left_withpress\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ rotate_left_withpress_loop }}'\n                sequence:\n                  - repeat:\n                      count: !input rotate_left_withpress_max_loop_repeats\n                      sequence: !input action_rotate_left_withpress\n      #\n      # Actions for Right With Press Rotate [Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-rotate-right-withpress-cmnd\n              - zha-rotate-right-withpress-cmnd\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: rotate_right_withpress\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_rotate_right_withpress\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ rotate_right_withpress_loop }}'\n                sequence:\n                  - repeat:\n                      count: !input rotate_right_withpress_max_loop_repeats\n                      sequence: !input action_rotate_right_withpress\n      #\n      # Actions for Click Short press [Event Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-click-short-evnt\n              - zha-click-short-evnt\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_short\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_short\n      #\n      # Actions for Click Double press [Event Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-click-double-evnt\n              - zha-click-double-evnt\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_double\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_double\n      #\n      # Actions for Click Short Press / Double Press Virtual [Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-click-short-cmnd\n              - zha-click-short-cmnd\n        sequence:\n          - if:\n              - condition: template\n                value_template: '{{ click_double_press_exposed }}'\n            # Handle Click Double Press Event\n            then:\n              - choose:\n                  # wait for z2m/zha/dcz triggers for double press\n                  - conditions: []\n                    sequence:\n                      - wait_for_trigger:\n                          # z2m trigger\n                          - trigger: device\n                            domain: mqtt\n                            device_id: !input controller_device\n                            type: action\n                            subtype: toggle\n                          # zha trigger\n                          - trigger: event\n                            event_type: zha_event\n                            event_data:\n                              device_id: !input controller_device\n                              command: toggle\n                              cluster_id: 6\n                              endpoint_id: 1\n                        timeout:\n                          milliseconds: '{{ helper_double_press_delay }}'\n                        continue_on_timeout: true\n                      - if:\n                          - condition: template\n                            value_template: '{{ wait.trigger.idx is defined }}'\n                        then:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: click_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_click_double\n                        else:\n                          # fire the ahb hook event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: click_short\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_click_short\n            # Not Up Double Handle Up Single Press Event\n            else:\n              # fire the ahb hook event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: click_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_click_short\n      #\n      # Actions for Click Long press [Event Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-click-long-evnt\n              - zha-click-long-evnt\n        sequence:\n          # fire the ahb hook event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_long\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_click_long\n      #\n      # Actions for Click Long Press [Command Mode]\n      - conditions:\n          - condition: trigger\n            id:\n              - z2m-click-long-cmnd\n              - zha-click-long-cmnd\n        sequence:\n          # fire the ahb event only once, the ahb hook will take care of looping\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: click_long\n          # run the custom action only once before entering repeat\n          - choose:\n              - conditions: []\n                sequence: !input action_click_long\n          # handle custom action looping if looping is enabled\n          - choose:\n              - conditions: '{{ click_long_loop }}'\n                sequence:\n                  # Repeat the Long Press Actions for the set number of loops\n                  - repeat:\n                      count: !input click_long_max_loop_repeats\n                      sequence:\n                        - parallel:\n                            - sequence: !input action_click_long\n                            - sequence:\n                                - choose:\n                                    - conditions: []\n                                      # Wait for triggers for Button Long Press Release to stop looping\n                                      sequence:\n                                        - wait_for_trigger:\n                                            # z2m triggers\n                                            - trigger: device\n                                              domain: mqtt\n                                              device_id: !input controller_device\n                                              type: action\n                                              subtype: hue_stop\n                                            # zha triggers\n                                            - trigger: event\n                                              event_type: zha_event\n                                              event_data:\n                                                device_id: !input controller_device\n                                                command: stop_move_step\n                                                endpoint_id: 1\n                                                cluster_id: 768\n                                          timeout:\n                                            milliseconds: !input helper_long_press_delay\n                                          continue_on_timeout: true\n                                        # If a Button Long Release is triggered wait.trigger.idx will be defined stop the loop before long_max_loop_repeats\n                                        - if:\n                                            - condition: template\n                                              value_template: '{{ wait.trigger.idx is defined }}'\n                                          then:\n                                            # Stop the repeat loop\n                                            - stop: click_long_stopped\n"},9159:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Controller - IKEA E1812 TR\xc5DFRI Shortcut button\n  description: |\n    # Controller - IKEA E1812 TR\xc5DFRI Shortcut button\n\n    Controller automation for executing any kind of action triggered by the provided IKEA E1812 TR\xc5DFRI Shortcut button. Allows to optionally loop an action on a button long press.\n    Supports deCONZ, ZHA, Zigbee2MQTT.\n\n    Automations created with this blueprint can be connected with one or more [Hooks](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks) supported by this controller.\n    Hooks allow to easily create controller-based automations for interacting with media players, lights, covers and more.\n    See the list of [Hooks available for this controller](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812#available-hooks) for additional details.\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.20\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/controllers/ikea_e1812).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/controllers/ikea_e1812/ikea_e1812.yaml\n  domain: automation\n  homeassistant:\n    min_version: 2024.10.0\n  input:\n    integration:\n      name: (Required) Integration\n      description: Integration used for connecting the remote with Home Assistant. Select one of the available values.\n      selector:\n        select:\n          options:\n            - deCONZ\n            - ZHA\n            - Zigbee2MQTT\n    controller_device:\n      name: (deCONZ, ZHA, Zigbee2MQTT Required) Controller Device\n      description: The controller device to use for the automation. Choose a value only if the remote is integrated with deCONZ, ZHA, Zigbee2MQTT.\n      default: ''\n      selector:\n        device:\n          filter:\n            # source: https://www.zigbee2mqtt.io/devices/E1812.html#ikea-e1812\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI shortcut button\n            # For backwards compatability with z2m 1.x. model_id is added to end of model rather than a seperate attribute in z2m 2.x\n            - integration: mqtt\n              manufacturer: IKEA\n              model: TRADFRI shortcut button (E1812)\n            # source: https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices\n            - integration: zha\n              manufacturer: IKEA of Sweden\n              model: TRADFRI SHORTCUT Button\n            - integration: deconz\n              manufacturer: IKEA of Sweden\n              model: TRADFRI SHORTCUT Button\n          multiple: false\n    helper_last_controller_event:\n      name: (Required) Helper - Last Controller Event\n      description: Input Text used to store the last event fired by the controller. You will need to manually create a text input entity for this, please read the blueprint Additional Notes for more info.\n      default: ''\n      selector:\n        entity:\n          domain: input_text\n    # inputs for custom actions\n    action_button_short:\n      name: (Optional) Button short press\n      description: Action to run on short button press.\n      default: []\n      selector:\n        action:\n    action_button_long:\n      name: (Optional) Button long press\n      description: Action to run on long button press.\n      default: []\n      selector:\n        action:\n    action_button_release:\n      name: (Optional) Button release\n      description: Action to run on button release after long press.\n      default: []\n      selector:\n        action:\n    action_button_double:\n      name: (Optional) (Virtual) Button double press\n      description: Action to run on double button press.\n      default: []\n      selector:\n        action:\n    # inputs for looping custom actions on long button press events until the corresponding release event is received\n    button_long_loop:\n      name: (Optional) Button long press - loop until release\n      description: Loop the button action until the button is released.\n      default: false\n      selector:\n        boolean:\n    button_long_max_loop_repeats:\n      name: (Optional) Button long press - Maximum loop repeats\n      description: >-\n        Maximum number of repeats for the custom action, when looping is enabled.\n        Use it as a safety limit to prevent an endless loop in case the corresponding stop event is not received.\n      default: 500\n      selector:\n        number:\n          min: 1\n          max: 5000\n          mode: slider\n          step: 1\n    # inputs for enabling double press events\n    button_double_press:\n      name: (Optional) Expose button double press event\n      description: Choose whether or not to expose the virtual double press event for the button. Turn this on if you are providing an action for the button double press event.\n      default: false\n      selector:\n        boolean:\n    # helpers used to properly recognize the remote button events\n    helper_double_press_delay:\n      name: (Optional) Helper - Double Press delay\n      description: Max delay between the first and the second button press for the double press event. Provide a value only if you are using a double press action. Increase this value if you notice that the double press action is not triggered properly.\n      default: 500\n      selector:\n        number:\n          min: 100\n          max: 5000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n    helper_debounce_delay:\n      name: (Optional) Helper - Debounce delay\n      description:\n        Delay used for debouncing RAW controller events, by default set to 0. A value of 0 disables the debouncing feature. Increase this value if you notice custom actions or linked Hooks running multiple times when interacting with the device. When the controller needs to be debounced,\n        usually a value of 100 is enough to remove all duplicate events.\n      default: 0\n      selector:\n        number:\n          min: 0\n          max: 1000\n          unit_of_measurement: milliseconds\n          mode: box\n          step: 10\n# Automation schema\nvariables:\n  # convert input tags to variables, to be used in templates\n  integration: !input integration\n  button_long_loop: !input button_long_loop\n  button_long_max_loop_repeats: !input button_long_max_loop_repeats\n  button_double_press: !input button_double_press\n  helper_last_controller_event: !input helper_last_controller_event\n  helper_double_press_delay: !input helper_double_press_delay\n  helper_debounce_delay: !input helper_debounce_delay\n  # integration id used to select items in the action mapping\n  integration_id: '{{ integration | lower }}'\n  # adjusted debounce delay so that the resulting double press delay is exactly as specified by the user when running the action, taking also account of debouncing\n  # make sure it never goes below the minimum double press delay\n  adjusted_double_press_delay: '{{ [helper_double_press_delay - helper_debounce_delay, 100] | max }}'\n  # mapping between actions and integrations\n  actions_mapping:\n    deconz:\n      button_short: ['1002']\n      button_long: ['1001']\n      button_release: ['1003']\n    zha:\n      button_short: ['on']\n      button_long: [move_with_on_off_0_83]\n      button_release: [stop]\n    zigbee2mqtt:\n      # source: https://www.zigbee2mqtt.io/devices/E1812.html#ikea-e1812\n      button_short: ['on']\n      button_long: [brightness_move_up]\n      button_release: [brightness_stop]\n  # pre-choose actions for buttons based on configured integration\n  # no need to perform this task at automation runtime\n  button_short: '{{ actions_mapping[integration_id][\"button_short\"] }}'\n  button_long: '{{ actions_mapping[integration_id][\"button_long\"] }}'\n  button_release: '{{ actions_mapping[integration_id][\"button_release\"] }}'\n  # build data to send within a controller event\n  controller_id: !input controller_device\nmode: restart\nmax_exceeded: silent\ntriggers:\n  # triggers for zigbee2mqtt mqtt device action\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: 'on'\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_move_up\n  - trigger: device\n    domain: mqtt\n    device_id: !input controller_device\n    type: action\n    subtype: brightness_stop\n  # triggers for other integrations\n  - trigger: event\n    event_type:\n      - deconz_event\n      - zha_event\n    event_data:\n      device_id: !input controller_device\nconditions:\n  - condition: and\n    conditions:\n      # check that the button event is not empty\n      - >-\n        {%- set trigger_action -%}\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n        {%- endset -%}\n        {{ trigger_action not in [\"\",\"None\"] }}\nactions:\n  # debouncing - when automation is triggered multiple times, the last automation run is the one which completes execution, due to mode restart\n  # therefore previous runs must wait for the debounce delay before executing any other action\n  # if the delay expires and the automation is still running it means it's the last run and execution can continue\n  - delay:\n      milliseconds: !input helper_debounce_delay\n  # extract button event from the trigger\n  # provide a single string value to check against\n  - variables:\n      trigger_action: >-\n        {%- if integration_id == \"zigbee2mqtt\" -%}\n        {{ trigger.payload }}\n        {%- elif integration_id == \"deconz\" -%}\n        {{ trigger.event.data.event }}\n        {%- elif integration_id == \"zha\" -%}\n        {{ trigger.event.data.command }}{{\"_\" if trigger.event.data.args|length > 0}}{{ trigger.event.data.args|join(\"_\") }}\n        {%- endif -%}\n      trigger_delta: '{{ (as_timestamp(now()) - ((states(helper_last_controller_event) | from_json).t if helper_last_controller_event is not none and (states(helper_last_controller_event) | regex_match(\"^\\{((\\\"a\\\":\\\".*\\\"|\\\"t\\\":\\d+\\.\\d+)(,)?){2}\\}$\")) else as_timestamp(\"1970-01-01 00:00:00\"))) * 1000 }}'\n  # update helper\n  - action: input_text.set_value\n    data:\n      entity_id: !input helper_last_controller_event\n      value: '{{ {\"a\":trigger_action,\"t\":as_timestamp(now())} | to_json }}'\n  # choose the sequence to run based on the received button event\n  - choose:\n      - conditions: '{{ trigger_action | string in button_short }}'\n        sequence:\n          - choose:\n              # if double press event is enabled\n              - conditions: '{{ button_double_press }}'\n                sequence:\n                  - choose:\n                      # if previous event was a short press\n                      - conditions: '{{ trigger_action | string in states(helper_last_controller_event) and trigger_delta | int <= helper_double_press_delay | int }}'\n                        sequence:\n                          # store the double press event in the last controller event helper\n                          - action: input_text.set_value\n                            data:\n                              entity_id: !input helper_last_controller_event\n                              value: '{{ {\"a\":\"double_press\",\"t\":as_timestamp(now())} | to_json }}'\n                          # run the double press action\n                          # fire the event\n                          - event: ahb_controller_event\n                            event_data:\n                              controller: '{{ controller_id }}'\n                              action: button_double\n                          # run the custom action\n                          - choose:\n                              - conditions: []\n                                sequence: !input action_button_double\n                    # previous event was not a short press\n                    default:\n                      # wait for the double press event to occur, within the provided delay\n                      # if the second press is received, automation is restarted\n                      - delay:\n                          milliseconds: '{{ adjusted_double_press_delay }}'\n                      # if delay expires, no second press was received, therefore run the short press action\n                      # run the short press action\n                      # fire the event\n                      - event: ahb_controller_event\n                        event_data:\n                          controller: '{{ controller_id }}'\n                          action: button_short\n                      # run the custom action\n                      - choose:\n                          - conditions: []\n                            sequence: !input action_button_short\n            # if double press event is disabled run the action for the single short press\n            default:\n              # fire the event\n              - event: ahb_controller_event\n                event_data:\n                  controller: '{{ controller_id }}'\n                  action: button_short\n              # run the custom action\n              - choose:\n                  - conditions: []\n                    sequence: !input action_button_short\n      - conditions: '{{ trigger_action | string in button_long }}'\n        sequence:\n          # fire the event only once before looping the action\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_long\n          - choose:\n              # if looping is enabled, loop the action for a finite number of iterations\n              - conditions: '{{ button_long_loop }}'\n                sequence:\n                  - repeat:\n                      while: '{{ repeat.index < button_long_max_loop_repeats | int }}'\n                      sequence: !input action_button_long\n            # if looping is not enabled run the custom action only once\n            default: !input action_button_long\n      - conditions: '{{ trigger_action | string in button_release }}'\n        sequence:\n          # fire the event\n          - event: ahb_controller_event\n            event_data:\n              controller: '{{ controller_id }}'\n              action: button_release\n          # run the custom action\n          - choose:\n              - conditions: []\n                sequence: !input action_button_release\n"},9250:e=>{"use strict";e.exports="# Blueprint metadata\nblueprint:\n  name: Hook - Media Player\n  description: |\n    # Hook - Media Player\n\n    Hook automation which allows to control a media player. Supports volume setting, play/pause and track selection. Features may vary depending on the selected Controller.\n\n    An automation created with this blueprint must be linked to a [Controller](https://epmatt.github.io/awesome-ha-blueprints/blueprints/controllers) automation.\n    Controllers are blueprints which allow to easily integrate a wide range of controllers (wall switches, remotes, dimmers, etc.) and use them to run a set of actions when interacting with them.\n    They expose an abstract interface used by Hooks to create controller-based automations.\n\n    A list of controllers supported by this hook is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player#supported-controllers).\n\n    ## More Info\n\n    \u2139\ufe0f Version 2025.03.29\n    \ud83d\udcdd [Changelog](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player/#changelog)\n    \ud83d\udcd5 Full documentation regarding this blueprint is available [here](https://epmatt.github.io/awesome-ha-blueprints/docs/blueprints/hooks/media_player).\n\n    \ud83d\ude80 This blueprint is part of the **[Awesome HA Blueprints](https://epmatt.github.io/awesome-ha-blueprints) project**. Please consider **[leaving a star on GitHub](https://github.com/EPMatt/awesome-ha-blueprints)**! \ud83c\udf1f\n\n  source_url: https://github.com/EPMatt/awesome-ha-blueprints/blob/main/blueprints/hooks/media_player/media_player.yaml\n  domain: automation\n  input:\n    controller_device:\n      name: (Required) Controller Device\n      description: The controller device which will control the Media Player. Choose a value only if the integration used to connect the controller to Home Assistant exposes it as a Device. This value should match the one specified in the corresponding Controller automation.\n      default: ''\n      selector:\n        device:\n    controller_model:\n      name: (Required) Controller model\n      description: The model for the controller used in this automation. Choose a value from the list of supported controllers.\n      selector:\n        select:\n          options:\n            - Aqara WXKG11LM Wireless Mini Switch\n            - IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote\n            - IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer\n            - IKEA E1744 SYMFONISK Rotary Remote\n            - IKEA E1766 TR\xc5DFRI Open/Close Remote\n            - IKEA E1812 TR\xc5DFRI Shortcut button\n            - IKEA E2001/E2002 STYRBAR Remote control\n            - IKEA E2123 SYMFONISK sound remote, gen 2\n            - IKEA E2201 RODRET Dimmer\n            - IKEA E2213 SOMRIG shortcut button\n            - IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer\n            - OSRAM AC025XX00NJ SMART+ Switch Mini\n            - Philips 324131092621 Hue Dimmer switch\n            - Philips 8718699693985 Hue Smart Button\n            - Philips 929002398602 Hue Dimmer switch v2\n            - SONOFF SNZB-01 Wireless Switch\n            - Tuya ERS-10TZBVK-AA Smart knob\n            - Xiaomi WXCJKG11LM Aqara Opple 2 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote\n            - Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2)\n            - Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3)\n            - Xiaomi WXKG01LM Mi Wireless Switch\n    media_player:\n      name: (Required) Media Player\n      description: Media player which will be controlled with this automation.\n      selector:\n        entity:\n          domain: media_player\n    volume_steps_short:\n      name: (Optional) Volume steps - short actions\n      description: Number of steps from min to max volume when controlling volume with short actions (eg. button press), if the media player supports it.\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 100\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n    volume_steps_long:\n      name: (Optional) Volume steps - long actions\n      description: Number of steps from min to max volume when controlling volume with long actions (eg. button hold or controller rotation), if the media player supports it.\n      default: 10\n      selector:\n        number:\n          min: 1\n          max: 100\n          step: 1\n          unit_of_measurement: steps\n          mode: box\n# Automation schema\nvariables:\n  # convert blueprint inputs into variables to be used in templates\n  controller_model: !input controller_model\n  # supported controllers and mappings\n  controller_mapping:\n    Aqara WXKG11LM Wireless Mini Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    IKEA E1524/E1810 TR\xc5DFRI Wireless 5-Button Remote:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_left_short\n      next_track: button_right_short\n      play_pause: button_center_short\n      stop: button_center_long\n    IKEA E1743 TR\xc5DFRI On/Off Switch & Dimmer:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_long\n      play_pause: button_down_double\n    IKEA E1744 SYMFONISK Rotary Remote:\n      volume_down_repeat: rotate_left\n      volume_up_repeat: rotate_right\n      play_pause: click_short\n      next_track: click_double\n      prev_track: click_triple\n    IKEA E1766 TR\xc5DFRI Open/Close Remote:\n      volume_up: button_up_short\n      next_track: button_up_double\n      volume_down: button_down_short\n      play_pause: button_down_double\n    IKEA E1812 TR\xc5DFRI Shortcut button:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    IKEA E2001/E2002 STYRBAR Remote control:\n      play_pause: button_up_short\n      volume_up_repeat: button_up_long\n      stop: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_left_short\n      next_track: button_right_short\n    IKEA E2123 SYMFONISK sound remote, gen 2:\n      play_pause: button_center_short\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n      next_track: button_right_short\n      prev_track: button_left_short\n      toggle: button_dots2_short\n      stop: button_dots1_short\n    IKEA E2201 RODRET Dimmer:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_long\n      play_pause: button_down_double\n    IKEA E2213 SOMRIG shortcut button:\n      volume_up: button_dots1_short\n      volume_up_repeat: button_dots1_long\n      next_track: button_dots1_double\n      volume_down: button_dots2_short\n      volume_down_repeat: button_dots2_long\n      play_pause: button_dots2_double\n    IKEA ICTC-G-1 TR\xc5DFRI wireless dimmer:\n      volume_down_repeat: rotate_left\n      volume_up_repeat: rotate_right\n    OSRAM AC025XX00NJ SMART+ Switch Mini:\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      next_track: button_up_double\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n      prev_track: button_down_double\n      play_pause: button_center_short\n      toggle: button_center_long\n    Philips 324131092621 Hue Dimmer switch:\n      play_pause: button_on_short\n      next_track: button_on_long\n      stop: button_off_short\n      prev_track: button_off_long\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n    Philips 8718699693985 Hue Smart Button:\n      play_pause: button_short\n      next_track: button_double\n    Philips 929002398602 Hue Dimmer switch v2:\n      play_pause: button_on_short\n      next_track: button_on_long\n      stop: button_off_short\n      prev_track: button_off_long\n      volume_up: button_up_short\n      volume_up_repeat: button_up_long\n      volume_down: button_down_short\n      volume_down_repeat: button_down_long\n    SONOFF SNZB-01 Wireless Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n    Tuya ERS-10TZBVK-AA Smart knob:\n      volume_up: rotate_right\n      volume_down: rotate_left\n      play_pause: click_short\n      next_track: click_double\n      prev_track: click_long\n    Xiaomi WXCJKG11LM Aqara Opple 2 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG12LM Aqara Opple 4 button remote (#2):\n      volume_up: button_3_short\n      volume_up_repeat: button_3_long\n      next_track: button_3_double\n      volume_down: button_4_long\n      play_pause: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote:\n      volume_up: button_1_short\n      volume_up_repeat: button_1_long\n      next_track: button_1_double\n      volume_down: button_2_long\n      play_pause: button_2_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#2):\n      volume_up: button_3_short\n      volume_up_repeat: button_3_long\n      next_track: button_3_double\n      volume_down: button_4_long\n      play_pause: button_4_double\n    Xiaomi WXCJKG13LM Aqara Opple 6 button remote (#3):\n      volume_up: button_5_short\n      volume_up_repeat: button_5_long\n      next_track: button_5_double\n      volume_down: button_6_long\n      play_pause: button_6_double\n    Xiaomi WXKG01LM Mi Wireless Switch:\n      play_pause: button_short\n      stop: button_long\n      next_track: button_double\n  # pre-choose actions for buttons based on configured controller\n  # no need to perform this task at automation runtime\n  volume_up: '{{ controller_mapping[controller_model][\"volume_up\"] | default(None) }}'\n  volume_up_repeat: '{{ controller_mapping[controller_model][\"volume_up_repeat\"] | default(None) }}'\n  volume_down: '{{ controller_mapping[controller_model][\"volume_down\"] | default(None) }}'\n  volume_down_repeat: '{{ controller_mapping[controller_model][\"volume_down_repeat\"] | default(None) }}'\n  next_track: '{{ controller_mapping[controller_model][\"next_track\"] | default(None) }}'\n  prev_track: '{{ controller_mapping[controller_model][\"prev_track\"] | default(None) }}'\n  stop: '{{ controller_mapping[controller_model][\"stop\"] | default(None) }}'\n  play_pause: '{{ controller_mapping[controller_model][\"play_pause\"] | default(None) }}'\n  toggle: '{{ controller_mapping[controller_model][\"toggle\"] | default(None) }}'\n  volume_steps_short: !input volume_steps_short\n  volume_steps_long: !input volume_steps_long\n  media_player: !input media_player\n  volume_step_value_short: '{{ 1/volume_steps_short }}'\n  volume_step_value_long: '{{ 1/volume_steps_long }}'\nmode: restart\nmax_exceeded: silent\ntriggers:\n  - trigger: event\n    event_type: ahb_controller_event\n    event_data:\n      controller: !input controller_device\ncondition: []\nactions:\n  - variables:\n      action: '{{ trigger.event.data.action }}'\n  - choose:\n      - conditions: '{{ action == play_pause }}'\n        sequence:\n          - action: media_player.media_play_pause\n            entity_id: !input media_player\n      - conditions: '{{ action == stop }}'\n        sequence:\n          - action: media_player.media_stop\n            entity_id: !input media_player\n      - conditions: '{{ action == next_track }}'\n        sequence:\n          - action: media_player.media_next_track\n            entity_id: !input media_player\n      - conditions: '{{ action == prev_track }}'\n        sequence:\n          - action: media_player.media_previous_track\n            entity_id: !input media_player\n      - conditions: '{{ action == toggle }}'\n        sequence:\n          - action: media_player.toggle\n            entity_id: !input media_player\n      - conditions: '{{ action == volume_up }}'\n        sequence:\n          - choose:\n              # if the volume level can be read from the media player, increase the volume by the custom step value\n              - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                sequence:\n                  - action: media_player.volume_set\n                    entity_id: !input media_player\n                    data:\n                      volume_level: '{{ [ state_attr(media_player, \"volume_level\")+volume_step_value_short, 1 ] | min  }}'\n            # if the volume level is not available, fallback to the media_player.volume_up service\n            default:\n              - action: media_player.volume_up\n                entity_id: !input media_player\n      - conditions: '{{ action == volume_down }}'\n        sequence:\n          - choose:\n              # if the volume level can be read from the media player, decrease the volume by the custom step value\n              - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                sequence:\n                  - action: media_player.volume_set\n                    entity_id: !input media_player\n                    data:\n                      volume_level: '{{ [ state_attr(media_player, \"volume_level\")-volume_step_value_short, 0 ] | max }}'\n            # if the volume level is not available, fallback to the media_player.volume_down service\n            default:\n              - action: media_player.volume_down\n                entity_id: !input media_player\n      - conditions: '{{ action == volume_up_repeat }}'\n        sequence:\n          - repeat:\n              while: '{{ true }}'\n              sequence:\n                - choose:\n                    # if the volume level can be read from the media player, increase the volume by the custom step value\n                    - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                      sequence:\n                        - action: media_player.volume_set\n                          entity_id: !input media_player\n                          data:\n                            volume_level: '{{ [ state_attr(media_player, \"volume_level\")+volume_step_value_long, 1 ] | min  }}'\n                  # if the volume level is not available, fallback to the media_player.volume_up service\n                  default:\n                    - action: media_player.volume_up\n                      entity_id: !input media_player\n                - delay:\n                    milliseconds: 250\n      - conditions: '{{ action == volume_down_repeat }}'\n        sequence:\n          - repeat:\n              while: '{{ true }}'\n              sequence:\n                - choose:\n                    # if the volume level can be read from the media player, decrease the volume by the custom step value\n                    - conditions: '{{ state_attr(media_player, \"volume_level\") != None }}'\n                      sequence:\n                        - action: media_player.volume_set\n                          entity_id: !input media_player\n                          data:\n                            volume_level: '{{ [ state_attr(media_player, \"volume_level\")-volume_step_value_long, 0 ] | max }}'\n                  # if the volume level is not available, fallback to the media_player.volume_down service\n                  default:\n                    - action: media_player.volume_down\n                      entity_id: !input media_player\n                - delay:\n                    milliseconds: 250\n"},9569:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/hooks","title":"Hooks","description":"Provide common functionality to any of the supported controllers. Build controller-based automations for lights, media players, covers and much more in just a few clicks.","source":"@site/docs/blueprints/hooks.mdx","sourceDirName":"blueprints","slug":"/blueprints/hooks","permalink":"/awesome-ha-blueprints/docs/blueprints/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/hooks.mdx","tags":[],"version":"current","frontMatter":{"title":"Hooks","description":"Provide common functionality to any of the supported controllers. Build controller-based automations for lights, media players, covers and much more in just a few clicks."},"sidebar":"docs","previous":{"title":"Controllers","permalink":"/awesome-ha-blueprints/docs/blueprints/controllers"},"next":{"title":"Automations","permalink":"/awesome-ha-blueprints/docs/blueprints/automation"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Hooks",description:"Provide common functionality to any of the supported controllers. Build controller-based automations for lights, media players, covers and much more in just a few clicks."},a=void 0,d={},c=[];function u(e){const n={a:"a",admonition:"admonition",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Hooks are part of the ",(0,i.jsx)(n.strong,{children:"Controllers-Hooks Ecosystem"}),". You can read more about this topic ",(0,i.jsx)(n.a,{href:"/docs/controllers-hooks-ecosystem",children:"here"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Hooks"})," are blueprints which seamlessly integrate with ",(0,i.jsx)(n.a,{href:"controllers",children:"Controllers"})," to enable control of lights, media players, covers and much more, without having to write a single line of code."]}),"\n",(0,i.jsx)(n.p,{children:"While Controllers are responsible for integrating the hardware and exposing an abstract interface to the user, Hooks can link to this interface and listen for events fired by a controller, taking care of providing the actual control functionality for common use cases."}),"\n",(0,i.jsx)(s.VO,{category:"hooks"})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},9893:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"blueprints/automation/example","title":"Example Automation Blueprint","description":"A description for the blueprint","source":"@site/docs/blueprints/automation/example.mdx","sourceDirName":"blueprints/automation","slug":"/blueprints/automation/example","permalink":"/awesome-ha-blueprints/docs/blueprints/automation/example","draft":false,"unlisted":false,"editUrl":"https://github.com/EPMatt/awesome-ha-blueprints/edit/main/docs/blueprints/automation/example.mdx","tags":[],"version":"current","frontMatter":{"title":"Example Automation Blueprint","description":"A description for the blueprint"}}');var i=t(7557),r=t(7389),s=t(2864);const l={title:"Example Automation Blueprint",description:"A description for the blueprint"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Additional Notes",id:"additional-notes",level:2}];function u(e){const n={a:"a",em:"em",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s._x,{id:"example",category:"automation"}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Describe here which goals your blueprint is trying to achieve. Provide also a brief description of how it works internally."})}),"\n",(0,i.jsx)(n.p,{children:"This example automation blueprint creates a persistent notification whenever the provided input boolean goes on."}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"List here integrations, platforms, addons or any additional service which is strictly required to run this integration. Provide links for documentation about the requirement."})}),"\n",(0,i.jsxs)(s.Kg,{name:"Persistent Notification Integration",required:!0,children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Add here what this requirement is used for within the blueprint, as well as reference on how it should be configured to correctly integrate with the blueprint. It's advised to link to official documentation for the requirement here."})}),(0,i.jsx)(n.p,{children:"You must have this integration enabled on your system to run the automation. This should be activated by default so unless you tweaked the default configuration you're good to go."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.home-assistant.io/integrations/persistent_notification/",children:"Persistent Notification Integration Docs"})})]}),"\n",(0,i.jsx)(n.h2,{id:"inputs",children:"Inputs"}),"\n",(0,i.jsx)(s.G0,{category:"automation",id:"example"}),"\n",(0,i.jsx)(n.h2,{id:"additional-notes",children:"Additional Notes"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Add here additional information about the blueprint (screenshots, tests, known limitations or issues)."})}),"\n",(0,i.jsx)(n.p,{children:"This blueprint describes a task which, as tested on my system, should execute quickly. If for some reason the automation is quite slow and it gets triggered another time, it just gets restarted."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);